<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>3D Swing Set Builder | PlayMor Swing Sets</title>

    <style>
      #blank_slate_div {
        position: absolute;
        top: 0;
        left: 0;
        background: white;
        width: 100%;
        height: 100%;
        z-index: 11;
      }

      #swing_boy_img {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%);
        height: 50%;
      }

      .meter {
        position: absolute;
        height: 20px;
        top: 50%;
        width: 30%;
        left: 50%;
        transform: translate(-50%, -100%);
        background: #555;
        border-radius: 25px;
        padding: 10px;
        box-shadow: inset 0 -1px 1px rgba(255, 255, 255, 0.3);
      }

      .meter > span {
        display: block;
        height: 100%;
        border-top-right-radius: 8px;
        border-bottom-right-radius: 8px;
        border-top-left-radius: 20px;
        border-bottom-left-radius: 20px;
        background-color: rgb(192, 192, 192);
        background-image: linear-gradient(
          center bottom,
          rgb(64, 64, 64) 37%,
          rgb(192, 192, 192) 69%
        );
        box-shadow: inset 0 2px 9px rgba(255, 255, 255, 0.3),
          inset 0 -2px 6px rgba(0, 0, 0, 0.4);
        position: relative;
        overflow: hidden;
      }

      .slider {
        -webkit-appearance: none;
        width: 100%;
        height: 18px;
        border-radius: 5px;
        background: #d3d3d3;
        outline: none;
        opacity: 0.7;
        -webkit-transition: 0.2s;
        transition: opacity 0.2s;
      }

      .slider:hover {
        opacity: 1;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 13px;
        height: 21px;
        border: 0;
        background: url("images/image_35c36b8f.png");
        cursor: pointer;
      }

      .slider::-moz-range-thumb {
        width: 13px;
        height: 21px;
        border: 0;
        background: url("images/image_35c36b8f.png");
        cursor: pointer;
      }

      #info_dialog {
        display: none;
        width: 40vw;
        height: 40vh;
        position: absolute;
        left: 50vh;
        top: 7vh;
        background-color: white;
        font-family: Arial;
        font-size: 2vh;
        color: black;
        border: 1px solid gray;
        padding: 1vh;
      }

      #info_content {
        width: 100%;
      }

      #email_dialog {
        display: none;
        width: 40vw;
        height: 90vh;
        position: absolute;
        left: 50vh;
        top: 7vh;
        background-color: white;
        font-family: Arial;
        font-size: 2vh;
        color: black;
        border: 1px solid gray;
        padding: 1vh;
      }

      .close_button {
        position: absolute;
        top: 0.5vmax;
        right: 1vmax;
        cursor: pointer;
        font-size: 4vh;
      }

      .tab {
        height: 1px;
        padding: 1vh;
      }

      #throbber {
        display: none;
        position: absolute;
        left: 50%;
        top: 50%;
      }

      #tiny_throbber {
        top: 50vh;
        left: calc(50% - 30px);
        width: 60px;
        height: 60px;
        animation: spin 1s linear infinite;
      }

      #small_throbber {
        top: 50vh;
        left: calc(50% - 45px);
        width: 90px;
        height: 90px;
        animation: spin 1.5s linear infinite;
      }

      #medium_throbber {
        top: 50vh;
        left: calc(50% - 60px);
        width: 120px;
        height: 120px;
        animation: spin 2s linear infinite;
      }

      #big_throbber {
        top: 50vh;
        left: calc(50% - 75px);
        width: 150px;
        height: 150px;
        animation: spin 2.5s linear infinite;
      }

      #godzilla_throbber {
        top: 50vh;
        left: calc(50% - 90px);
        width: 180px;
        height: 180px;
        animation: spin 3s linear infinite;
      }

      body {
        margin: 0;
        overflow: hidden;
        background: grey;
      }

      .tab_button {
        height: 3vh;
        color: #888;
        font-size: 1.5vmax;
        border: 0;
        background-color: #ccc;
      }

      .tab_button:hover {
        background-color: #ccc;
      }

      .tab_button.active {
        color: black;
        background-color: white;
      }

      .tab_bar {
        height: 3vh;
      }

      button {
        height: 32px;
      }

      input {
        width: 100%;
        height: 32px;
      }

      textarea {
        width: 100%;
        resize: both;
        rows: 4;
      }

      .ui {
        position: fixed;
        width: 100%;
        font-family: "Segoe UI", Arial, sans-serif;
        z-index: 10;
      }

      .left-bar {
        position: absolute;
        height: calc(92vh - 18px);
        top: 4vh;
        left: 2.5vh;
        width: 12.5vh;
        background: rgba(0, 0, 0, 0.5);
        border: 4px solid white;
        padding: 5px;
      }

      #sub_step_container {
        width: 100%;
        height: calc(100% - 20px);
        overflow-y: scroll;
        margin: 10px 0;
      }

      #sub_step_container::-webkit-scrollbar {
        width: 6px;
      }

      #sub_step_container::-webkit-scrollbar-track {
        background-color: transparent;
      }

      #sub_step_container::-webkit-scrollbar-thumb {
        background-color: rgba(255, 255, 255, 0.8);
      }

      .steps {
        height: 14.2%;
        text-align: center;
        cursor: pointer;
        margin: 0px;
      }

      .step-text {
        color: #fff;
        font-size: 1.5vh;
        height: 15%;
      }

      .step-image {
        height: 75%;
        margin-top: 5%;
      }

      .right-bar {
        position: absolute;
        height: calc(92vh - 18px);
        top: 4vh;
        right: -30vh;
        width: 26vh;
        background: rgba(0, 0, 0, 0.5);
        border: 4px solid white;
        padding: 5px;
        transition: right 0.5s ease 0s;
        cursor: pointer;
      }

      .sub_item_container {
        width: 100%;
        height: calc(100% - 20px);
        overflow-y: scroll;
        margin: 10px 0;
      }

      .sub_item_container::-webkit-scrollbar {
        width: 6px;
      }

      .sub_item_container::-webkit-scrollbar-track {
        background-color: transparent;
      }

      .sub_item_container::-webkit-scrollbar-thumb {
        background-color: rgba(255, 255, 255, 0.8);
      }

      .sub-items {
        position: relative;
        width: 18vh;
        height: 21vh;
        margin: auto;
        margin-bottom: 8px;
      }

      .sub-item-image {
        width: 100%;
      }

      .sub-item-text {
        color: white;
        width: 100%;
        position: absolute;
        text-align: center;
        bottom: 0px;
        font-size: 1.8vh;
      }

      #show-right-btn {
        width: 25px;
        height: 50px;
        position: absolute;
        top: calc(50vh - 25px);
        right: 3vh;
        transition: right 0.5s ease 0s;
        cursor: pointer;
      }

      #show-right-btn img {
        width: 100%;
        height: 100%;
      }

      .controls {
        position: absolute;
        left: 22.5vh;
        cursor: pointer;
      }

      .top-controls {
        position: absolute;
        top: 4vh;
      }

      .xxxzoom-slder {
        width: 175px;
        height: 15px;
        position: absolute;
        top: 60px;
        left: 40px;
      }

      .xxzoom-top {
        display: inline;
        width: 30px;
        height: 30px;
      }

      .xxxzoomtop_img {
        width: 30px;
        height: 30px;
      }

      .zoom-bottom {
        width: 28px;
        height: 28px;
        top: 55px;
        left: 5px;
      }

      .zoom-bottom img {
        width: 100%;
        height: 100%;
      }

      #zum_div {
        display: flex;
        margin-top: 10px;
      }

      .zum_image {
        width: 28px;
        height: 28px;
      }

      .xxxui-slider-handle {
        border: 2px solid white !important;
        width: 10px !important;
        height: 20px !important;
        background-color: rgba(0, 0, 0, 0.5) !important;
      }

      .controls-buttons {
        display: flex;
      }

      .controls-buttons-right {
        display: flex;
      }

      .controls-buttons-item {
        width: 40px;
        height: 40px;
        margin-right: 20px;
        background: white;
        border-radius: 20px;
        border: 1px white solid;
        cursor: pointer;
      }

      .controls-buttons-item img {
        width: 100%;
        height: 100%;
      }

      .bottom-controls {
        position: absolute;
        top: calc(100vh - 70px);
      }

      .bottom-controls-right {
        position: absolute;
        top: calc(100vh - 70px);
        right: 25px;
        transition: right 0.5s ease 0s;
      }

      .custom-controls {
        display: none;
        padding: 10px 15px 10px 15px;
        border-radius: 20px;
        background: rgba(0, 0, 0, 0.5);
        position: absolute;
        top: calc(100vh - 180px);
        left: calc(50vw - 200px);
      }

      #custom-controls-delete {
        width: 50px;
        height: 50px;
      }

      #custom-controls-delete img {
        width: 100%;
        height: 100%;
      }

      .custom-controls-line {
        height: 55px;
        width: 3px;
        margin: 0 10px;
        margin-top: -2.5px;
        background: rgba(255, 255, 255, 0.8);
      }

      .custom-controls-color-container {
        display: contents;
      }

      .custom-controls-color {
        width: 50px;
        height: 50px;
        margin-right: 10px;
        border-radius: 26px;
        border: 2px solid white;
      }

      .custom-controls-color img {
        width: 100%;
        height: 100%;
      }

      .custom-controls-roof {
        display: none;
        padding: 10px 15px 10px 15px;
        border-radius: 20px;
        background: rgba(0, 0, 0, 0.5);
        position: absolute;
        top: calc(100vh - 220px);
        left: calc(50vw - 200px);
      }

      .custom-controls-roof-content {
        display: inline-flex;
        width: 100%;
        padding: 5px;
      }

      .custom-controls-text {
        color: white;
        line-height: 50px;
        height: 50px;
        width: 70px;
        text-align: left;
      }

      #info-modal-container {
        display: none;
        position: absolute;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.8);
      }

      #info-modal {
        position: absolute;
        width: 85vh;
        height: 75vh;
        top: 12.5vh;
        left: calc(50vw - 42.5vh);
        background: rgba(255, 255, 255, 0.8);
      }

      #info-modal-close {
        position: absolute;
        width: 40px;
        height: 40px;
        background: white;
        top: -20px;
        right: -20px;
        border-radius: 21px;
        border: 2px solid rgba(0, 0, 0, 0.8);
      }

      #info-modal-text {
        width: calc(100% - 40px);
        margin: 25px 10px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
      }

      #measurement-display {
        display: none;
        position: absolute;
        bottom: -4px;
        left: 200px;
        width: 250px;
        height: 50px;
        background: rgba(0, 0, 0, 0.5);
        color: white;
        line-height: 50px;
        font-size: 2rem;
        text-align: center;
      }

      .mulch {
        width: 36vh;
        border-radius: 4vh;
        background: rgba(0, 0, 0, 0.5);
        left: 22.5vh;
        top: calc(39vh - 70px);
        cursor: pointer;
        position: absolute;
        display: none;
      }

      .mulch-length-slider {
        width: 100%;
        height: 15px;
      }

      .mulch-width-slider {
        width: 100%;
        height: 15px;
      }

      .mulch-content {
        height: 100vh;
      }

      .mulch-options {
        padding: 3.2vh;
        color: white;
        font-family: "Segoe UI", Arial, sans-serif;
      }

      .mulch-options-title {
        display: flex;
        position: relative;
        margin-bottom: 10px;
      }

      .mulch-options-title-first {
        font-size: 3.1vh;
      }

      .mulch-options-title-second {
        font-size: 2vh;
        position: absolute;
        left: 12.5vh;
        bottom: 2px;
      }

      .mulch-options-title-third {
        font-size: 2vh;
        position: absolute;
        left: 9.75vh;
        bottom: 2px;
      }

      .mulch-options-item {
        display: flex;
        height: 7vh;
        line-height: 7vh;
        width: 100%;
      }

      .mulch-options-item-title {
        width: 10vh;
        font-size: 2vh;
      }

      .mulch-options-item-content {
        width: calc(100% - 10vh);
        font-size: 2vh;
        line-height: 7vh;
        margin-top: calc(3.5vh - 10px);
      }

      .mulch-options-item-checkbox {
        width: 3vh;
        height: 3vh;
        margin-top: -2px;
        border: 2px white solid;
        position: relative;
      }

      .mulch-options-item-checkbox img {
        width: 5vh;
        top: -1.8vh;
        position: absolute;
      }

      .mulch-options-material {
        width: 7vh;
        margin: 0px 10px;
        height: 7vh;
        border-radius: 5vh;
        border: 2px solid white;
      }

      .mulch-options-material-content {
        margin-bottom: 2vh;
        margin-top: 0.5vh;
      }

      .mulch-options-material-content img {
        width: 100%;
      }

      .custom-controls-color-canopy {
        display: contents;
      }

      .custom-controls-color-poly {
        display: contents;
      }

      .xxxslidecontainer {
        display: inline;
        width: 100%;
      }

      .xxxslider {
        -webkit-appearance: none;

        height: 30px;
        background: #d3d3d3;
        outline: none;
        opacity: 0.7;
        -webkit-transition: 0.2s;
        transition: opacity 0.2s;
      }

      .xxxslider:hover {
        opacity: 1;
      }

      .xxxslider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 25px;
        height: 25px;
        background: #04aa6d;
        cursor: pointer;
      }

      .xxxslider::-moz-range-thumb {
        width: 25px;
        height: 25px;
        background: #04aa6d;
        cursor: pointer;
      }

      .throbber_arc {
        position: absolute;
        border: 12px solid rgba(0, 0, 0, 0);
        border-top: 12px solid rgb(221, 144, 29);
        border-radius: 50%;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      #playground_snapshot {
        width: 100%;
        text-align: center;
        background-color: white;
      }

      #tab_bar {
        height: 2.5vw;
        width: 100%;
        background-color: white;
        display: flex;
      }

      .background_tab_button {
        float: left;
        border-bottom: 1px solid gray;
        padding: 0.5vh;
        cursor: pointer;
      }

      .foreground_tab_button {
        float: left;
        border-right: 1px solid gray;
        border-top: 1px solid gray;
        border-left: 1px solid gray;
        padding: 0.5vh;
      }

      .fill_tab_button {
        float: left;
        border-bottom: 1px solid gray;
        flex-grow: 1;
      }

      #tab_content {
        width: 100%;
        border-right: 1px solid gray;
        border-bottom: 1px solid gray;
        border-left: 1px solid gray;
      }

      #button_bar {
        height: 3vw;
        width: 100%;
        background-color: white;
        display: flex;
      }

      .contact_label {
      }

      input {
        width: 100%;
        height: 4vh;
        font-family: Arial;
        font-size: 2vh;
      }

      textarea {
        width: 100%;
        resize: both;
        rows: 4;
        font-family: Arial;
        font-size: 2vh;
      }

      table {
        width: 100%;
        overflow: hidden;
        overflow-y: scroll;
      }

      thead,
      tbody {
        display: block;
      }

      tbody {
        overflow-y: auto;
        overflow-x: hidden;
      }

      tr {
        height: 5vh;
      }

      .header_cell {
        width: 33%;
      }

      .small_print {
        font-size: 1vh;
      }

      #instructions_dialog {
        display: none;
        width: 40vw;
        height: 40vh;
        position: absolute;
        left: 50vh;
        top: 7vh;
        background-color: white;
        font-family: Arial;
        font-size: 2vh;
        color: black;
        border: 1px solid gray;
        padding: 1vh;
      }

      #instructions_content {
        width: 100%;
      }
    </style>
  </head>

  <body>
    <div id="blank_slate_div" style="display: none">
      <div id="progress_div" class="meter">
        <span id="green_span" style="width: 101%"></span>
      </div>
      <img
        id="swing_boy_img"
        src="images/image_82959c74.png"
      />
    </div>

    <div class="ui">
      <div class="controls">
        <div class="top-controls">
          <div class="controls-buttons">
            <div id="controls-buttons-info" class="controls-buttons-item">
              <img
                src="images/image_a0c48939.png"
              />
            </div>
            <div id="controls-buttons-recenter" class="controls-buttons-item">
              <img
                src="images/image_05890187.png"
              />
            </div>
            <div
              id="controls-buttons-refresh"
              style="border: 0px; background: transparent"
              class="controls-buttons-item"
            >
              <img
                src="images/image_18df01d8.png"
              />
            </div>
            <div id="controls-buttons-undo" class="controls-buttons-item">
              <img
                src="images/image_c5adb9e5.png"
              />
            </div>
            <div
              id="controls-buttons-center-mulch"
              class="controls-buttons-item"
            >
              <img
                src="images/image_0cdd7e4b.png"
              />
            </div>
          </div>
          <div id="zum_div">
            <img
              id="zum_in_button"
              class="zum_image"
              src="images/image_8b139000.png"
            />
            <input
              class="slider"
              type="range"
              min="1"
              max="49"
              value="10"
              id="zum_slider"
            />
            <img
              id="zum_out_button"
              class="zum_image"
              src="images/image_c31154da.png"
            />
          </div>
        </div>
        <div class="bottom-controls">
          <div class="controls-buttons">
            <div id="controls-buttons-mulch" class="controls-buttons-item">
              <img
                src="images/image_d574641e.png"
              />
            </div>
            <div id="controls-buttons-switch" class="controls-buttons-item">
              <img
                src="images/image_9c3714ff.png"
              />
            </div>
            <div
              id="controls-buttons-measurement"
              class="controls-buttons-item"
            >
              <img
                src="images/image_ab10b2d8.png"
              />
            </div>
            <div id="controls-buttons-help" class="controls-buttons-item">
              <img
                src="images/image_c33b1a9e.png"
              />
            </div>
          </div>
          <div id="measurement-display" style="display: none">0 x 0</div>
        </div>
      </div>
      <div class="mulch" style="display: block">
        <div class="mulch-options">
          <div class="mulch-options-title">
            <div class="mulch-options-title-first">MULCH</div>
            <div class="mulch-options-title-second">OPTIONS</div>
          </div>
          <div class="mulch-options-item">
            <div class="mulch-options-item-title">ENABLED</div>
            <div class="mulch-options-item-content">
              <div class="mulch-options-item-checkbox">
                <img
                  src="images/image_fcb71549.png"
                />
              </div>
            </div>
          </div>
          <div class="mulch-options-item">
            <div class="mulch-options-item-title">LENGTH</div>
            <div class="mulch-options-item-content">
              <div class="slidecontainer">
                <input
                  type="range"
                  min="5"
                  max="50"
                  value="10"
                  class="slider"
                  id="mulch_length_slider"
                />
              </div>
            </div>
          </div>
          <div class="mulch-options-item">
            <div class="mulch-options-item-title">WIDTH</div>
            <div class="mulch-options-item-content">
              <div class="slidecontainer">
                <input
                  type="range"
                  min="5"
                  max="50"
                  value="10"
                  class="slider"
                  id="mulch_width_slider"
                />
              </div>
            </div>
          </div>
          <div class="mulch-options-item mulch-options-material-content">
            <div
              id="mulch-options-material-left"
              class="mulch-options-material"
            >
              <img
                src="images/image_315c775f.png"
              />
            </div>
            <div
              id="mulch-options-material-right"
              class="mulch-options-material"
            >
              <img
                src="images/image_a7e75c5a.png"
              />
            </div>
          </div>
          <div class="mulch-options-title">
            <div class="mulch-options-title-first">CURB</div>
            <div class="mulch-options-title-third">OPTIONS</div>
          </div>
          <div class="mulch-options-item mulch-options-material-content">
            <div id="mulch-options-crub-left" class="mulch-options-material">
              <img
                src="images/image_53984dfc.png"
              />
            </div>
            <div id="mulch-options-crub-right" class="mulch-options-material">
              <img
                src="images/image_20799396.png"
              />
            </div>
          </div>
        </div>
      </div>

      <div class="left-bar">
        <div class="sub_step_container" id="sub_step_container">
          <h6 class="steps" id="steps-0">
            <img
              class="step-image"
              src="images/image_95eb4509.png"
              style="opacity: 1; background: transparent"
            />
            <div class="step-text">1.Tower</div>
          </h6>
          <h6 class="steps" id="steps-1">
            <img
              class="step-image"
              src="images/image_611b458c.png"
              style="opacity: 1; background: transparent"
            />
            <div class="step-text">2.Swing beam</div>
          </h6>
          <h6 class="steps" id="steps-2">
            <img
              class="step-image"
              src="images/image_0503539b.png"
              style="opacity: 1; background: transparent"
            />
            <div class="step-text">3.Swings</div>
          </h6>
          <h6 class="steps" id="steps-3">
            <img
              class="step-image"
              src="images/image_5524963f.png"
              style="opacity: 1; background: transparent"
            />
            <div class="step-text">4.Kits</div>
          </h6>
          <h6 class="steps" id="steps-4">
            <img
              class="step-image"
              src="images/image_8d2acb6c.png"
              style="opacity: 1; background: rgb(192, 192, 192)"
            />
            <div class="step-text">5.Entry point</div>
          </h6>
          <h6 class="steps" id="steps-5">
            <img
              class="step-image"
              src="images/image_249c7ebb.png"
              style="opacity: 1; background: transparent"
            />
            <div class="step-text">6.Slides</div>
          </h6>
          <h6 class="steps" id="steps-6">
            <img
              class="step-image"
              src="images/image_fd42e184.png"
              style="opacity: 1; background: transparent"
            />
            <div class="step-text">7.Toys</div>
          </h6>
        </div>
      </div>
      <div id="show-right-btn" style="right: calc(40px + 26vh)">
        <img
          src="images/image_ae5a2d14.png"
        />
      </div>
      <div class="bottom-controls-right" style="right: calc(40px + 26vh)">
        <div class="controls-buttons">
          <div id="controls-buttons-upload" class="controls-buttons-item">
            <img
              src="images/image_8c253f38.png"
            />
          </div>
          <div id="controls-buttons-download" class="controls-buttons-item">
            <img
              src="images/image_b63c07cf.png"
            />
          </div>
          <div id="controls-buttons-mail" class="controls-buttons-item">
            <img
              src="images/image_66d66c82.png"
            />
          </div>
        </div>
      </div>
      <div class="right-bar" style="right: 10px">
        <div class="sub_item_container" id="sub_item_container">
          <h6 class="sub-items" id="sub-items-0">
            <div class="sub-item-text">Cargo net</div>
            <img
              class="sub-item-image"
              src="images/image_507fc15b.png"
            />
          </h6>
          <h6 class="sub-items" id="sub-items-1">
            <div class="sub-item-text">Combo climbing</div>
            <img
              class="sub-item-image"
              src="images/image_3a2dd7a7.png"
            />
          </h6>
          <h6 class="sub-items" id="sub-items-2">
            <div class="sub-item-text">Climbing pole</div>
            <img
              class="sub-item-image"
              src="images/image_4d042197.png"
            />
          </h6>
          <h6 class="sub-items" id="sub-items-3">
            <div class="sub-item-text">Fireman pole</div>
            <img
              class="sub-item-image"
              src="images/image_5639f543.png"
            />
          </h6>
          <h6 class="sub-items" id="sub-items-4">
            <div class="sub-item-text">Gang plank 4 ft</div>
            <img
              class="sub-item-image"
              src="images/image_601ec133.png"
            />
          </h6>
          <h6 class="sub-items" id="sub-items-5">
            <div class="sub-item-text">Gang plank 5 ft</div>
            <img
              class="sub-item-image"
              src="images/image_42baf42c.png"
            />
          </h6>
          <h6 class="sub-items" id="sub-items-7">
            <div class="sub-item-text">Monkey bar climber 4 ft</div>
            <img
              class="sub-item-image"
              src="images/image_fbbe3bd6.png"
            />
          </h6>
          <h6 class="sub-items" id="sub-items-8">
            <div class="sub-item-text">Monkey bar climber 5 ft</div>
            <img
              class="sub-item-image"
              src="images/image_fbbe3bd6.png"
            />
          </h6>
          <h6 class="sub-items" id="sub-items-9">
            <div class="sub-item-text">Poly rock climb 5 ft</div>
            <img
              class="sub-item-image"
              src="images/image_0ba4708b.png"
            />
          </h6>
          <h6 class="sub-items" id="sub-items-11">
            <div class="sub-item-text">Steps 4 ft</div>
            <img
              class="sub-item-image"
              src="images/image_d79b3747.png"
            />
          </h6>
          <h6 class="sub-items" id="sub-items-12">
            <div class="sub-item-text">Steps 5 ft</div>
            <img
              class="sub-item-image"
              src="images/image_76ba2961.png"
            />
          </h6>
          <h6 class="sub-items" id="sub-items-14">
            <div class="sub-item-text">Monkey bar attachment</div>
            <img
              class="sub-item-image"
              style="filter: grayscale(100%)"
              src="images/image_7ba73527.png"
            />
          </h6>
          <h6 class="sub-items" id="sub-items-14">
            <div class="sub-item-text">Poly rock climb 7 ft</div>
            <img
              class="sub-item-image"
              style="filter: grayscale(100%)"
              src="images/image_bc632756.png"
            />
          </h6>
          <h6 class="sub-items" id="sub-items-14">
            <div class="sub-item-text">Steps 7 ft</div>
            <img
              class="sub-item-image"
              style="filter: grayscale(100%)"
              src="images/image_33764303.png"
            />
          </h6>
        </div>
      </div>
      <div
        class="custom-controls"
        style="display: none; left: calc(-164.5px + 50vw)"
      >
        <div id="custom-controls-delete">
          <img
            src="images/image_6eedc2a9.png"
          />
        </div>
        <div class="custom-controls-line"></div>
        <div class="custom-controls-color-container">
          <div
            onclick="Colorize ( 0x004983)"
            class="custom-controls-color custom-controls-poly-color"
            style="background-color: #004983"
          ></div>
          <div
            onclick="Colorize ( 0x01664b)"
            class="custom-controls-color custom-controls-poly-color"
            style="background-color: #01664b"
          ></div>
          <div
            onclick="Colorize ( 0xffcb05)"
            class="custom-controls-color custom-controls-poly-color"
            style="background-color: #ffcb05"
          ></div>
          <div
            onclick="Colorize ( 0x93293b)"
            class="custom-controls-color custom-controls-poly-color"
            style="background-color: #93293b"
          ></div>
          <div
            onclick="Colorize ( 0x5b5e67)"
            class="custom-controls-color custom-controls-poly-color"
            style="background-color: #5b5e67"
          ></div>
        </div>
      </div>

      <div class="custom-controls-roof" style="display: none">
        <div class="custom-controls-roof-content">
          <div class="custom-controls-text">CANOPY</div>
          <div class="custom-controls-line"></div>
          <div class="custom-controls-color-canopy">
            <div
              onclick="Change_roof_canopy_color ( 0x004983)"
              class="custom-controls-color custom-controls-poly-color"
              index="1"
              style="background-color: #004983"
            ></div>
            <div
              onclick="Change_roof_canopy_color ( 0x01664b)"
              class="custom-controls-color custom-controls-poly-color"
              index="2"
              style="background-color: #01664b"
            ></div>
            <div
              onclick="Change_roof_canopy_color ( 0x5b5e67)"
              class="custom-controls-color custom-controls-poly-color"
              index="3"
              style="background-color: #5b5e67"
            ></div>
            <div
              onclick="Change_roof_canopy_color ( 0xffcb05)"
              class="custom-controls-color custom-controls-poly-color"
              index="4"
              style="background-color: #ffcb05"
            ></div>
            <div
              onclick="Change_roof_canopy_color ( 0x93293b)"
              class="custom-controls-color custom-controls-poly-color"
              index="5"
              style="background-color: #93293b"
            ></div>
            <div
              onclick="Change_roof_canopy_color ( `tricolors` )"
              class="custom-controls-color custom-controls-poly-color"
              index="6"
              style="background-color: tricolors"
            >
              <img
                src="images/image_ae45a138.png"
              />
            </div>
          </div>
        </div>
        <div class="custom-controls-roof-content">
          <div class="custom-controls-text">POLY</div>
          <div class="custom-controls-line"></div>
          <div class="custom-controls-color-poly">
            <div
              onclick="Change_roof_poly_color ( 0x01664b)"
              class="custom-controls-color custom-controls-poly-color"
              index="1"
              style="background-color: #01664b"
            ></div>
            <div
              onclick="Change_roof_poly_color ( 0x5b5e67)"
              class="custom-controls-color custom-controls-poly-color"
              index="2"
              style="background-color: #5b5e67"
            ></div>
          </div>
        </div>
      </div>

      <div id="info-modal-container">
        <div id="info-modal">
          <div id="info-modal-close"></div>
          <div id="info-modal-text"></div>
        </div>
      </div>

      <div id="email_dialog" style="padding: 31px; height: 790px">
        <div id="email_dialog_title" style="height: 79px">
          <label><b>Get a quote</b></label>
          <a
            class="close_button"
            onclick='email_dialog . style . display = "none" ; throbber . style . display = "none" ;'
            >×</a
          >
          <hr />
        </div>
        <div id="playground_snapshot" style="height: 158px"></div>
        <br />
        <div id="tab_bar" style="height: 39px">
          <div
            id="contact_tab_button"
            onmousedown="Show_contact_tab ()"
            class="foreground_tab_button"
          >
            CONTACT
          </div>
          <div
            id="product_tab_button"
            onmousedown="Show_product_tab ()"
            class="background_tab_button"
          >
            PRODUCT
          </div>
          <div id="fill_tab_button" class="fill_tab_button"></div>
        </div>
        <div id="tab_content" style="height: 397px">
          <div id="contact_tab" class="tab">
            <table>
              <tbody>
                <tr>
                  <td class="header_cell">
                    <label class="contact_label">First Name</label>
                  </td>
                  <td>
                    <input
                      id="first_name"
                      type="text"
                      onchange="Enable_disable_send_email_button ()"
                      onkeypress="Enable_disable_send_email_button ()"
                    />
                  </td>
                </tr>
                <tr>
                  <td class="header_cell">
                    <label class="contact_label">Last Name</label>
                  </td>
                  <td>
                    <input
                      id="last_name"
                      type="text"
                      onchange="Enable_disable_send_email_button ()"
                      onkeypress="Enable_disable_send_email_button ()"
                    />
                  </td>
                </tr>
                <tr>
                  <td class="header_cell">
                    <label class="contact_label">Email Address</label>
                  </td>
                  <td>
                    <input
                      id="email"
                      type="text"
                      onchange="Enable_disable_send_email_button ()"
                      onkeypress="Enable_disable_send_email_button ()"
                    />
                  </td>
                </tr>
                <tr style="height: 0.25vh">
                  <td></td>
                  <td>
                    <label class="small_print"
                      >We'll never share your email with anyone else</label
                    >
                  </td>
                </tr>
                <tr>
                  <td class="header_cell">
                    <label class="contact_label">Phone number</label>
                  </td>
                  <td>
                    <input
                      id="phone_number"
                      type="text"
                      onchange="Enable_disable_send_email_button ()"
                      onkeypress="Enable_disable_send_email_button ()"
                    />
                  </td>
                </tr>
                <tr>
                  <td class="header_cell">
                    <label class="contact_label">Zip code</label>
                  </td>
                  <td>
                    <input
                      id="zip_code"
                      type="text"
                      onchange="Enable_disable_send_email_button ()"
                      onkeypress="Enable_disable_send_email_button ()"
                    />
                  </td>
                </tr>
                <tr>
                  <td class="header_cell">
                    <label class="contact_label">Notes</label>
                  </td>
                  <td>
                    <textarea id="notes"></textarea>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <div id="product_tab" class="tab" style="display: none">
            <table id="product_table">
              <tbody id="email_body" style="height: 377px">
                <tr>
                  <td class="header_cell"></td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <br />
        <div id="button_bar" style="height: 7px">
          <button
            id="cancel_button"
            onclick='email_dialog . style . display = "none" ; throbber . style . display = "none" ;'
          >
            cancel
          </button>
          <button id="send_email_button" onclick="Send_mail ()" disabled="">
            send
          </button>
        </div>
      </div>

      <div id="info_dialog">
        <div id="info_dialog_title">
          <label id="info_dialog_title_label"><b>Parts list</b></label>
          <a
            class="close_button"
            onclick='info_dialog . style . display = "none"; show_info = false ;'
            >×</a
          >
          <hr />
        </div>
        <div id="info_content"></div>
      </div>

      <div
        id="instructions_dialog"
        style="padding: 35px; height: 659px; display: none"
      >
        <div id="instructions_dialog_title" style="height: 89px">
          <label id="instructions_dialog_title_label"><b>INSTRUCTION</b></label>
          <a
            class="close_button"
            onclick='instructions_dialog . style . display = "none"; show_info = false ;'
            >×</a
          >
          <hr />
        </div>
        <div id="instructions_content" style="height: 535px">
          <table>
            <tbody>
              <tr id="space_row">
                <td>
                  <img
                    id="space_img"
                    src="images/image_89a5bba1.png"
                    style="height: 49.6111px"
                  />
                </td>
                <td>TAP SPACE BAR TO ROTATE TOWERS, SLIDES AND SWINGS</td>
              </tr>
              <tr id="esc_row">
                <td>
                  <img
                    id="esc_img"
                    src="images/image_275f9244.png"
                    style="height: 49.6111px"
                  />
                </td>
                <td>WHILE HOLDING AN ITEM TAP ESC BUTTON TO END A SELECTION</td>
              </tr>
            </tbody>
          </table>
          <table id="buttons_help">
            <tbody id="buttons_help_body">
              <tr>
                <td id="product_list_cell" style="width: 496.5px">
                  <img
                    id="product_list_img"
                    src="images/image_a0c48939.png"
                    style="height: 49.6111px"
                  />
                  PRODUCT LIST
                </td>
                <td style="width: 50%">
                  <img
                    id="mulch_options_img"
                    src="images/image_d574641e.png"
                    style="height: 49.6111px"
                  />
                  MULCH OPTIONS
                </td>
              </tr>
              <tr>
                <td>
                  <img
                    id="center_camera_img"
                    src="images/image_05890187.png"
                    style="height: 49.6111px"
                  />
                  CENTER CAMERA
                </td>
                <td>
                  <img
                    id="background_img"
                    src="images/image_9c3714ff.png"
                    style="height: 49.6111px"
                  />
                  BACKGROUND
                </td>
              </tr>
              <tr>
                <td>
                  <img
                    id="refresh_img"
                    src="images/image_18df01d8.png"
                    style="height: 49.6111px"
                  />
                  REFRESH
                </td>
                <td>
                  <img
                    id="size_img"
                    src="images/image_ab10b2d8.png"
                    style="height: 49.6111px"
                  />
                  SIZE
                </td>
              </tr>
              <tr>
                <td>
                  <img
                    id="undo_img"
                    src="images/image_c5adb9e5.png"
                    style="height: 49.6111px"
                  />
                  UNDO
                </td>
                <td>
                  <img
                    id="instructions_img"
                    src="images/image_c33b1a9e.png"
                    style="height: 49.6111px"
                  />
                  INSTRUCTION
                </td>
              </tr>
              <tr>
                <td>
                  <img
                    id="center_mulch_img"
                    src="images/image_0cdd7e4b.png"
                    style="height: 49.6111px"
                  />
                  CENTER MULCH
                </td>
                <td>
                  <img
                    id="get_quote_img"
                    src="images/image_66d66c82.png"
                    style="height: 49.6111px"
                  />
                  GET QUOTE
                </td>
              </tr>
              <tr>
                <td>
                  <img
                    id="download_img"
                    src="images/image_b63c07cf.png"
                    style="height: 49.6111px"
                  />
                  DOWNLOAD
                </td>
                <td>
                  <img
                    id="upload_img"
                    src="images/image_8c253f38.png"
                    style="height: 49.6111px"
                  />
                  UPLOAD
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div id="throbber">
        <div id="godzilla_throbber" class="throbber_arc"></div>
        <div id="big_throbber" class="throbber_arc"></div>
        <div id="medium_throbber" class="throbber_arc"></div>
        <div id="small_throbber" class="throbber_arc"></div>
        <div id="tiny_throbber" class="throbber_arc"></div>
      </div>
    </div>

    <script>
      //let box3s = []

      const Deg2Rad = Math.PI / 180;
      const Meters2Feet = 3.28084;

      const Mode = {
        normal: 0,
        placing: 1,
        plugging: 2,
        mode: 0,
      };

      const Yaws = [
        180, 90, 0, 270, 270, 180, 90, 0, 0, 270, 180, 90, 90, 0, 270, 180, 270,
        180, 90, 0, 0, 270, 180, 90, 90, 0, 270, 180, 180, 90, 0, 270, 0, 270,
        180, 90, 90, 0, 270, 180, 180, 90, 0, 270, 270, 180, 90, 0, 90, 0, 270,
        180, 180, 90, 0, 270, 270, 180, 90, 0, 0, 270, 180, 90,
      ];

      let canvas;
      let context;
      let scene;
      let white_color;
      let scene_render_target;
      let email_render_target;
      let email_scene_snapshot;
      let camera;
      let renderer;
      let clock;
      let raycaster;
      let mouse;
      let interval_id;
      let blueprint;
      let outliner;
      let thumbnailer;
      let mulch = null;
      let skybox = null;
      let shader_time = 0;
      let dashOffset = 0;
      let shadows = true;
      let joint_image = null;
      let joint_image_frame = 0;
      let joint_image_frames = 0;
      let file_button;
      let link = document.createElement("a");
      let intersection_object;
      let intersection_point;
      let intersection_mesh;
      let switchboard = [];
      let adopted = 0;
      let show_mesurements = false;
      let measurements = "0.00' x 0.00' x 0.00'";
      let measurements_font_height = 32;
      let show_info = false;
      let part_list;
      let box3Helper = null;

      let models_with_available_joints = [];
      let picked_meshes = [];
      let picked_mesh = null;
      let host_joint = null;
      let plug_joint = null;
      let plug_joint_index = -1;
      let plug_model = null;

      class Blueprint {
        static states = [];

        constructor(args) {
          this.add_snapshot();
        }
        add_snapshot(args) {
          Blueprint.states.push(this.get_snapshot());
        }
        get_snapshot(args) {
          let index = 0;
          for (let mesh of picked_meshes) {
            let model = mesh.model;
            model.save_index = index++;
          }

          let blueprint = {
            yard: "v1.1",
            camera: {
              position: camera.position,
            },
            mulch: {
              enabled: mulch_enabled,
              width: mulch.width,
              depth: mulch.depth,
              bounds_texture_index: mulch.bounds_texture_index,
              plane_texture_index: mulch.plane_texture_index,
            },
            skybox: {
              visible: skybox.visible,
            },
            models_data: picked_meshes.map((mesh) => {
              let model = mesh.model;
              return {
                slope: model.slope,
                mirrorx: model.mirrorx,
                index: model.index,
                save_index: model.save_index,
                yaw: model.yaw,
                position: model.mesh.position,
                y_rotation: model.mesh.rotation.y,
                colorized: model.colorized,
                ruf: model.ruf,
                ruf_color: model.ruf_color,
                flags: model.get_flag_color_list(),
                joints: model.joints
                  .filter((joint) => joint.connected)
                  .map((joint) => {
                    return {
                      index: joint.index,
                      link: {
                        model_save_index: joint.connected.model.save_index,
                        joint_index: joint.connected.index,
                      },
                    };
                  }),
              };
            }),
          };
          return JSON.stringify(blueprint);
        }
        undo(args) {
          if (Blueprint.states.length > 1) {
            let states = Blueprint.states.slice();
            this.restore({ state: states.pop(), restore_camera: false });
            Blueprint.states = states.slice();
          } else blueprint.refresh();
        }
        redo(args) {}
        restore(args) {
          let state = JSON.parse(args.state);

          Refresh(args);

          let restore_camera = true;

          if (args)
            if ("restore_camera" in args) restore_camera = args.restore_camera;

          if (restore_camera)
            camera.position.set(
              state.camera.position.x,
              state.camera.position.y,
              state.camera.position.z
            );

          mulch_enabled = state.mulch.enabled;
          mulch.build({
            width: state.mulch.width,
            depth: state.mulch.depth,
            bounds_texture_index: state.mulch.bounds_texture_index,
            plane_texture_index: state.mulch.plane_texture_index,
          });

          skybox.visible = state.skybox.visible;

          models_with_available_joints = [];
          for (let model_data of state.models_data) {
            let model = Model.instances[model_data.index].clone();
            model.yaw = model_data.yaw;
            model.mesh.rotation.y = model_data.y_rotation;
            model.mesh.position.set(
              model_data.position.x,
              model_data.position.y,
              model_data.position.z
            );
            model.ruf = model_data.ruf;
            model.ruf_color = model_data.ruf_color;
            let flag_mesh_list = model.get_flag_mesh_list();
            for (let i = 0; i < model_data.flags.length; i++) {
              let flag_color = model_data.flags[i];
              let flag_mesh = flag_mesh_list[i];
              flag_mesh.material.color = new THREE.Color(
                parseInt("0x" + flag_color, 16)
              );
            }
            switch (model_data.ruf) {
              case "canopy":
                {
                  if (model.roof_poly_mesh)
                    model.roof_poly_mesh.visible = false;
                  model.roof_canopy_mesh.visible = true;
                  if (model.ruf_color == "tricolors") {
                    model.roof_canopy_mesh.traverse((mesh) => {
                      if ("material" in mesh)
                        mesh.material = model.roof_canopy_material.clone();
                    });
                  } else {
                    model.roof_canopy_mesh.traverse((mesh) => {
                      if ("material" in mesh)
                        mesh.material = new THREE.MeshStandardMaterial({
                          color: model.ruf_color,
                          side: THREE.DoubleSide,
                        });
                    });
                  }
                }
                break;
              case "poly":
                {
                  model.roof_canopy_mesh.visible = false;
                  model.roof_poly_mesh.visible = true;
                  //model . roof_poly_mesh . traverse ( mesh => {
                  //if ( 'material' in mesh )
                  //mesh . material . color = new THREE . Color ( { color : model . ruf_color } )
                  //} )
                }
                break;
            }
            for (let joint_data of model_data.joints) {
              let joint = model.joints[joint_data.index];
              if (
                !joint.connected &&
                joint_data.link.model_save_index <
                  models_with_available_joints.length
              ) {
                let model2 =
                  models_with_available_joints[
                    joint_data.link.model_save_index
                  ];
                let joint2 = model2.joints[joint_data.link.joint_index];

                if (
                  joint.layer == "s" ||
                  joint.layer == "sh" ||
                  joint.layer == "ds"
                ) {
                  let position = model.mesh.position;
                  let rotation = model.mesh.rotation;
                  let joint_index = model.joints.indexOf(joint);
                  model.morph({ layer: joint2.model.joints[0].layer });
                  joint = model.joints[joint_index];
                  model.mesh.position.copy(position);
                  model.mesh.rotation.copy(rotation);
                }

                if (joint.layer == "handle") {
                  joint.model.mesh.traverse((mesh) => {
                    if (mesh.name.indexOf("_colorize_") != -1)
                      mesh.rotation.x = model2.slope * Deg2Rad;
                  });
                }

                Connect_joints({ joint_1: joint, joint_2: joint2 });
              }
            }
            if (model_data.colorized) {
              model.colorized = model_data.colorized;

              let color_string = model.colorized.toString(16);
              if (color_string.length < 5) color_string = "0" + color_string;
              if (color_string.length < 6) color_string = "0" + color_string;

              let color = new THREE.Color("#" + color_string);

              model.mesh.traverse((mesh) => {
                if (mesh.name.indexOf("_colorize_") != -1)
                  mesh.material.color = color;
              });
            }
            model.mirrorx = model_data.mirrorx;
            if (model.mirrorx == 1) {
              model.mesh.scale.z = -1;
            }

            scene.add(model.mesh);
            picked_meshes.push(model.mesh);
            models_with_available_joints.push(model);
          }

          Show_items();
          Update_measurements();
        }
        refresh(args) {
          for (let model of Model.instances) model.selected = false;

          models_with_available_joints = [];
          picked_meshes = [];
          picked_mesh = null;
          host_joint = null;
          plug_joint = null;
          plug_joint_index = -1;
          plug_model = null;

          Hide_options();
          Blueprint.states = [this.get_snapshot()];
          display_mulch = true;
          mulch_enabled = true;
          Mode.mode = Mode.normal;
          Update_measurements();
          Show_items();

          let restore_camera = true;
          if ("restore_camera" in args) restore_camera = args.restore_camera;

          if (restore_camera) {
            camera.position.set(0, 10, 10);
            orbitControls.update();
        if (window.syncWorldRotationWithCamera) syncWorldRotationWithCamera();
          }
        }
      }
      class Skybox {
        constructor(args) {
          this.front;
          this.back;
          this.left;
          this.right;
          this.up;
          this.down;
          this.mesh = null;
          this.visible = true;
          this.boxGeometry = new THREE.BoxGeometry(100, 50, 100);

          this.mesh = new THREE.Mesh(
            this.boxGeometry,
            new THREE.MeshStandardMaterial()
          );
          this.mesh.name = "_skybox_";
          scene.add(this.mesh);
          this.mesh.position.set(0, 25, 0);
          this.mesh.visible = this.visible;

          Load_image_base_64({ base_64: Assets[6] }).then((resolution) => {
            this.left = resolution.resolution;
            Load_image_base_64({ base_64: Assets[7] }).then((resolution) => {
              this.right = resolution.resolution;
              Load_image_base_64({ base_64: Assets[8] }).then((resolution) => {
                this.down = resolution.resolution;
                let down_texture = new THREE.CanvasTexture(this.down);
                down_texture.wrapS = down_texture.wrapT = THREE.RepeatWrapping;
                down_texture.repeat.set(3, 3);
                down_texture.needsUpdate = true;
                Load_image_base_64({ base_64: Assets[9] }).then(
                  (resolution) => {
                    this.front = resolution.resolution;
                    let front_texture = new THREE.CanvasTexture(this.front);
                    Load_image_base_64({ base_64: Assets[10] }).then(
                      (resolution) => {
                        this.back = resolution.resolution;
                        scene.remove(this.mesh);
                        this.mesh = new THREE.Mesh(
                          new THREE.BoxGeometry(100, 50, 100),
                          [
                            new THREE.MeshBasicMaterial({
                              map: new THREE.CanvasTexture(this.right),
                              side: THREE.BackSide,
                            }),
                            new THREE.MeshBasicMaterial({
                              map: new THREE.CanvasTexture(this.back),
                              side: THREE.BackSide,
                            }),
                            new THREE.MeshBasicMaterial({
                              map: front_texture,
                              side: THREE.BackSide,
                            }),
                            new THREE.MeshBasicMaterial({
                              map: down_texture,
                              side: THREE.BackSide,
                            }),
                            new THREE.MeshBasicMaterial({
                              map: new THREE.CanvasTexture(this.left),
                              side: THREE.BackSide,
                            }),
                            new THREE.MeshBasicMaterial({
                              map: front_texture,
                              side: THREE.BackSide,
                            }),
                          ]
                        );
                        scene.add(this.mesh);
                        this.mesh.position.set(0, 25, 0);
                        this.mesh.visible = this.visible;
                      }
                    );
                  }
                );
              });
            });
          });
        }
        toggle(args) {
          this.visible = !this.visible;
          this.mesh.visible = this.visible;
        }
      }
      class Mulch {
        constructor(args) {
          this.width = 10;
          this.depth = 10;
          this.texture = null;
          this.meshes = [];
          this.bounds_textures = [];
          this.bounds_texture_index = 0;
          this.plane_textures = [];
          this.plane_texture_index = 0;

          Load_image_base_64({ base_64: Assets[0] }).then((resolution) => {
            let xtexture = new THREE.CanvasTexture(resolution.resolution);
            xtexture.wrapS = xtexture.wrapT = THREE.RepeatWrapping;
            xtexture.repeat.set(this.width, 0.5);
            xtexture.needsUpdate = true;
            this.bounds_textures.push(xtexture);

            Load_image_base_64({ base_64: Assets[1] }).then((resolution) => {
              let ztexture = new THREE.CanvasTexture(resolution.resolution);
              ztexture.wrapS = ztexture.wrapT = THREE.RepeatWrapping;
              ztexture.repeat.set(0.5, this.depth);
              ztexture.needsUpdate = true;
              this.bounds_textures.push(ztexture);

              Load_image_base_64({ base_64: Assets[2] }).then((resolution) => {
                let xtexture = new THREE.CanvasTexture(resolution.resolution);
                xtexture.wrapS = xtexture.wrapT = THREE.RepeatWrapping;
                xtexture.repeat.set(this.width, 1);
                xtexture.needsUpdate = true;
                this.bounds_textures.push(xtexture);
                let ztexture = new THREE.CanvasTexture(resolution.resolution);
                ztexture.wrapS = ztexture.wrapT = THREE.RepeatWrapping;
                ztexture.repeat.set(1, this.depth);
                ztexture.needsUpdate = true;
                this.bounds_textures.push(ztexture);

                Load_image_base_64({ base_64: Assets[3] }).then(
                  (resolution) => {
                    let texture = new THREE.CanvasTexture(
                      resolution.resolution
                    );
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(this.width / 2, this.depth / 2);
                    texture.needsUpdate = true;
                    this.plane_textures.push(texture);

                    Load_image_base_64({ base_64: Assets[4] }).then(
                      (resolution) => {
                        let texture = new THREE.CanvasTexture(
                          resolution.resolution
                        );
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        texture.repeat.set(this.width / 2, this.depth / 2);
                        texture.needsUpdate = true;
                        this.plane_textures.push(texture);

                        this.build();
                      }
                    );
                  }
                );
              });
            });
          });
        }
        build(args) {
          if (args) {
            if ("width" in args) this.width = args.width;
            if ("depth" in args) this.depth = args.depth;
            if ("bounds_texture_index" in args)
              this.bounds_texture_index = args.bounds_texture_index;
            if ("plane_texture_index" in args)
              this.plane_texture_index = args.plane_texture_index;
          }

          for (let mesh of this.meshes) scene.remove(mesh);

          this.meshes = [];

          let xtexture = this.bounds_textures[this.bounds_texture_index * 2];
          xtexture.repeat.set(this.width, 0.5);
          xtexture.needsUpdate = true;

          let ztexture =
            this.bounds_textures[this.bounds_texture_index * 2 + 1];
          ztexture.repeat.set(0.5, this.depth);
          ztexture.needsUpdate = true;

          let zbox_geometry = new THREE.BoxGeometry(
            0.25,
            0.125,
            this.depth + 0.24
          );
          // right
          let zbox1 = new THREE.Mesh(zbox_geometry, [
            new THREE.MeshStandardMaterial({ map: xtexture }), // right
            new THREE.MeshStandardMaterial({ map: xtexture }), // left
            new THREE.MeshStandardMaterial({ map: ztexture }), // top
            new THREE.MeshStandardMaterial({ map: ztexture }), // bottom ?
            new THREE.MeshStandardMaterial({ map: ztexture }), // front
            new THREE.MeshStandardMaterial({ map: ztexture }), // back
          ]);
          zbox1.position.x = this.width / 2;
          zbox1.receiveShadow = shadows;
          this.meshes.push(zbox1);
          scene.add(zbox1);
          zbox1.visible = false;
          // left
          let zbox2 = new THREE.Mesh(zbox_geometry, [
            new THREE.MeshStandardMaterial({ map: xtexture }),
            new THREE.MeshStandardMaterial({ map: xtexture }),
            new THREE.MeshStandardMaterial({ map: ztexture }),
            new THREE.MeshStandardMaterial({ map: ztexture }),
            new THREE.MeshStandardMaterial({ map: ztexture }),
            new THREE.MeshStandardMaterial({ map: ztexture }),
          ]);
          zbox2.position.x = -this.width / 2;
          zbox2.receiveShadow = shadows;
          this.meshes.push(zbox2);
          scene.add(zbox2);
          zbox2.visible = false;

          let xbox_material = new THREE.MeshStandardMaterial({ map: xtexture });
          let xbox_geometry = new THREE.BoxGeometry(
            this.width + 0.24,
            0.125,
            0.25
          );
          let xbox1 = new THREE.Mesh(xbox_geometry, xbox_material);
          xbox1.position.z = this.depth / 2;
          xbox1.receiveShadow = shadows;
          this.meshes.push(xbox1);
          scene.add(xbox1);
          xbox1.visible = false;
          let xbox2 = new THREE.Mesh(xbox_geometry, xbox_material);
          xbox2.position.z = -this.depth / 2;
          xbox2.receiveShadow = shadows;
          this.meshes.push(xbox2);
          scene.add(xbox2);
          xbox2.visible = false;

          let plane_texture = this.plane_textures[this.plane_texture_index];
          plane_texture.repeat.set(this.width / 2, this.depth / 2);
          plane_texture.needsUpdate = true;
          let plane_geometry = new THREE.PlaneGeometry(this.width, this.depth);
          let plane_material = new THREE.MeshStandardMaterial({
            map: plane_texture,
          });
          let plane = new THREE.Mesh(plane_geometry, plane_material);
          plane.rotation.x = -Math.PI / 2;
          plane.position.y = 0;
          plane.receiveShadow = shadows;
          this.meshes.push(plane);
          scene.add(plane);
          plane.visible = false;
        }
        center(args) {}
      }
      class Model {
        static instances = [];

        constructor(args) {
          this.mesh = null;
          this.joints = [];
          this.selected = false;
          this.yaw = 0;
          this.roof_canopy_mesh = null;
          this.roof_canopy_material = null;
          this.roof_poly_mesh = null;
          this.layer = "";
          this.layers = [];
          this.meshes = [];
          this.index = Model.instances.length;
          this.category = -1;
          this.children_index = -1;
          this.colorized = null;
          this.ruf = "";
          this.ruf_color = null;
          this.original = null;
          this.mirrorx = -1;
          this.slope = 0;
          this.tubular = false;

          if (args) {
            if ("category" in args) this.category = args.category;
            if ("children_index" in args)
              this.children_index = args.children_index;
            if ("category_child" in args) {
              if ("tubular" in args.category_child)
                this.tubular = args.category_child.tubular;
              if ("glb" in args.category_child)
                this.adopt({ base_64: args.category_child.glb });
              if ("glbs" in args.category_child)
                for (let glb of args.category_child.glbs)
                  this.adopt({ base_64: glb.glb, layer: glb.layer });
              if ("slope" in args.category_child)
                this.slope = args.category_child.slope;
            }
          }

          Model.instances.push(this);
        }
        morph(args) {
          if (args.layer == this.layer) return;

          let found = false;
          let i = 0;
          while (!found && i < this.layers.length)
            found = this.layers[i++] == args.layer;
          if (found) {
            this.mesh = this.meshes[--i];
            this.joints = [];
            this.mesh.traverse((mesh) => {
              mesh.model = this;
              mesh.castShadow = shadows;
              mesh.receiveShadow = shadows;
              if (mesh.name.toLowerCase().startsWith("roof_canopy"))
                this.roof_canopy_mesh = mesh;
              if (mesh.name.toLowerCase().startsWith("roof_poly"))
                this.roof_poly_mesh = mesh;
              if (mesh.name.toLowerCase().startsWith("joint")) {
                let splits = mesh.name.split(",");
                mesh.direction = parseInt(splits[1]);
                mesh.layer = splits[2].toLowerCase();
                mesh.exclusion_layer = splits.length > 3 ? splits[3] : null;
                mesh.excluder_layer = splits.length > 4 ? splits[4] : null;
                mesh.available = true;
                mesh.visible = false;
                this.joints.push(mesh);
              }
            });
            
            // Add gray color option to mesh names (morph method)
            // Categories 0, 1, 2 are Tower, Swing beam, Swings
            // Categories 3, 4, 5 typically contain trim/accessories in yard design software
            // Category 6 is Toys
            if (this.category === 0 || this.category === 1 || this.category === 2 || this.category === 3 || this.category === 4 || this.category === 5 || this.category === 6) {
              if (this.mesh && this.mesh.children && this.mesh.children[0]) {
                let childMesh = this.mesh.children[0];
                if (childMesh.name && childMesh.name.includes('#')) {
                  // Check if gray color is not already in the name
                  if (!childMesh.name.includes('#5b5e67')) {
                    // Add gray color to the mesh name
                    childMesh.name += ',#5b5e67';
                  }
                }
              }
              
              // Also add gray color to roof mesh names for Tower and Toys (morph method)
              if (this.category === 0 || this.category === 6) {
                this.mesh.traverse((mesh) => {
                  if (mesh.name.toLowerCase().startsWith("roof_canopy") || 
                      mesh.name.toLowerCase().startsWith("roof_poly")) {
                    if (mesh.name.includes('#') && !mesh.name.includes('#5b5e67')) {
                      mesh.name += ',#5b5e67';
                    }
                  }
                });
              }
              
            }
          }
        }
        sort_joints(args) {
          // place ! @ #0
          let index = -1;
          let i = 0;
          let joint = null;
          while (index < 0 && i < this.joints.length) {
            joint = this.joints[i++];
            index = joint.name.indexOf("!");
          }
          if (index >= 0) {
            this.joints.splice(--i, 1);
            this.joints.splice(0, 0, joint);
          }
        }
        adopt(args) {
          Load_base_64({ base_64: args.base_64 }).then((resolution) => {
            this.mesh = resolution.resolution;

            if ("layer" in args) {
              this.meshes.push(this.mesh);
              this.layers.push(args.layer);
            }

            this.mesh.traverse((mesh) => {
              mesh.model = this;
              mesh.castShadow = shadows;
              mesh.receiveShadow = shadows;
              if (mesh.name.toLowerCase().startsWith("roof_canopy")) {
                this.roof_canopy_mesh = mesh;
                this.roof_canopy_material = mesh.material;
              }
              if (mesh.name.toLowerCase().startsWith("roof_poly"))
                this.roof_poly_mesh = mesh;
              if (mesh.name.toLowerCase().startsWith("joint")) {
                let splits = mesh.name.split(",");
                mesh.direction = parseInt(splits[1]);
                mesh.layer = splits[2].toLowerCase();
                mesh.exclusion_layer = splits.length > 3 ? splits[3] : null;
                mesh.excluder_layer = splits.length > 4 ? splits[4] : null;
                mesh.available = true;
                mesh.visible = false;
                this.joints.push(mesh);
              }
              if (mesh.name.toLowerCase().indexOf("mirrorx") != -1)
                mesh.model.mirrorx = 0;
              // Add gray color to flag meshes
              if (mesh.name.toLowerCase().startsWith("flag")) {
                if (mesh.name.includes('#') && !mesh.name.includes('#5b5e67')) {
                  mesh.name += ',#5b5e67';
                } else if (!mesh.name.includes('#')) {
                  // If no colors defined, add some default colors including gray
                  mesh.name += ',#004983,#01664b,#ffcb05,#93293b,#5b5e67';
                }
              }
            });

            // Add gray color option to mesh names
            // Categories 0, 1, 2 are Tower, Swing beam, Swings
            // Categories 3, 4, 5 typically contain trim/accessories in yard design software
            // Category 6 is Toys
            if (this.category === 0 || this.category === 1 || this.category === 2 || this.category === 3 || this.category === 4 || this.category === 5 || this.category === 6) {
              if (this.mesh && this.mesh.children && this.mesh.children[0]) {
                let childMesh = this.mesh.children[0];
                if (childMesh.name && childMesh.name.includes('#')) {
                  // Check if gray color is not already in the name
                  if (!childMesh.name.includes('#5b5e67')) {
                    // Add gray color to the mesh name
                    childMesh.name += ',#5b5e67';
                  }
                }
              }
              
              // Add gray color to roof canopy mesh names, but not to poly roofs for Tower and Toys
              if (this.category === 0 || this.category === 6) {
                this.mesh.traverse((mesh) => {
                  if (mesh.name.toLowerCase().startsWith("roof_canopy")) {
                    if (mesh.name.includes('#') && !mesh.name.includes('#5b5e67')) {
                      mesh.name += ',#5b5e67';
                    }
                  }
                  // Process poly roofs but don't add gray color - just ensure they're processed
                  if (mesh.name.toLowerCase().startsWith("roof_poly")) {
                    // Poly roofs are processed but no gray color added
                  }
                });
              }
            }

            this.sort_joints();

            if (++adopted == 72) {
              blank_slate_div.style = "display : none";
            } else {
              green_span.style =
                "width :" + Math.trunc((adopted * 100) / 72) + "%;";
            }

            Show_items();
          });
        }
        promise(args) {
          return new Promise((resolve, reject) => {
            Load_base_64(args).then((resolution) => {
              this.mesh = resolution.resolution;

              //console . log ( '\n,' + Model . instances . indexOf ( this ) + ',' + this . mesh. name )
              this.mesh.traverse((mesh) => {
                mesh.model = this;
                mesh.castShadow = shadows;
                mesh.receiveShadow = shadows;
                if (mesh.name.toLowerCase().startsWith("joint")) {
                  let splits = mesh.name.split(",");
                  mesh.direction = parseInt(splits[1]);
                  mesh.available = true;
                  mesh.visible = false;
                  this.joints.push(mesh);

                  //console . log (  ',' + mesh . name + ',' + mesh . position . y + ',' + mesh . rotation . y )
                }
                // Add gray color to flag meshes
                if (mesh.name.toLowerCase().startsWith("flag")) {
                  if (mesh.name.includes('#') && !mesh.name.includes('#5b5e67')) {
                    mesh.name += ',#5b5e67';
                  } else if (!mesh.name.includes('#')) {
                    // If no colors defined, add some default colors including gray
                    mesh.name += ',#004983,#01664b,#ffcb05,#93293b,#5b5e67';
                  }
                }
              });

              resolve({ resolution: this });
            });
          });
        }
        clone(args) {
          let clone = new Model();
          clone.mesh = this.mesh.clone();
          clone.roof_canopy_mesh = null;
          clone.roof_poly_mesh = null;
          let mesh_index = 0;
          clone.mesh.traverse((mesh) => {
            if (mesh.material) mesh.material = mesh.material.clone();
            mesh.model = clone;
            mesh.castShadow = shadows;
            mesh.receiveShadow = shadows;
            if (
              clone.roof_canopy_mesh == null &&
              mesh.name.toLowerCase().startsWith("roof_canopy")
            ) {
              clone.roof_canopy_mesh = mesh;
              clone.roof_canopy_material = mesh.material;
            }
            if (
              clone.roof_poly_mesh == null &&
              mesh.name.toLowerCase().startsWith("roof_poly")
            )
              clone.roof_poly_mesh = mesh;
            if (clone.roof_canopy_mesh && clone.roof_poly_mesh)
              clone.roof_poly_mesh.visible = false;
            if (mesh.name.toLowerCase().startsWith("joint")) {
              let splits = mesh.name.split(",");
              mesh.direction = parseInt(splits[1]);
              mesh.layer = splits[2];
              mesh.exclusion_layer = splits.length > 3 ? splits[3] : null;
              mesh.excluder_layer = splits.length > 4 ? splits[4] : null;
              mesh.available = true;
              mesh.connected = null;
              mesh.visible = mesh.children.length != 0;
              mesh.index = mesh_index++;
              clone.joints.push(mesh);
            }
          });

          clone.sort_joints();

          clone.category = this.category;
          clone.children_index = this.children_index;
          clone.layers = this.layers;
          clone.index = this.index;
          clone.original = this;
          clone.mirrorx = this.mirrorx;
          clone.slope = this.slope;
          clone.tubular = this.tubular;

          for (let mesh of this.meshes) {
            let mesh_clone = mesh.clone();
            let mesh_index = 0;
            mesh_clone.traverse((mesh) => {
              if (mesh.material) mesh.material = mesh.material.clone();
              mesh.model = clone;
              mesh.castShadow = shadows;
              mesh.receiveShadow = shadows;
              if (
                clone.roof_canopy_mesh == null &&
                mesh.name.toLowerCase().startsWith("roof_canopy")
              )
                clone.roof_canopy_mesh = mesh;
              if (
                clone.roof_poly_mesh == null &&
                mesh.name.toLowerCase().startsWith("roof_poly")
              )
                clone.roof_poly_mesh = mesh;
              if (mesh.name.toLowerCase().startsWith("joint")) {
                let splits = mesh.name.split(",");
                mesh.direction = parseInt(splits[1]);
                mesh.layer = splits[2];
                mesh.exclusion_layer = splits.length > 3 ? splits[3] : null;
                mesh.excluder_layer = splits.length > 4 ? splits[4] : null;
                mesh.available = true;
                mesh.connected = null;
                mesh.visible = mesh.children.length != 0;
                mesh.index = mesh_index++;
                clone.joints.push(mesh);
              }
            });
            clone.meshes.push(mesh_clone);
          }

          return clone;
        }
        capable(args) {
          let found = false;

          // check for an empty tarmac
          if (picked_meshes.length == 0) {
            // bail if wildcard model
            let jokers = 0;
            for (let joint of this.joints) if (joint.layer == "*") jokers++;
            return jokers == 0 && this.category == 0;
          }

          // check for available joints
          for (let model of models_with_available_joints)
            for (let joint of model.joints)
              if (!found && joint.available) found = true;
          // no available joints to connect to
          // can't add disconnected models
          if (!found) return false;

          // check if i'm a wildcard
          let i = 0;
          found = false;
          while (!found && i < this.joints.length)
            found = "*" == this.joints[i++].layer;
          if (found) {
            // search for an available valid host joint that's not a wildcard
            let valid = 0;
            for (let model of models_with_available_joints)
              for (let joint of model.joints)
                if (
                  joint.available &&
                  joint.layer[0] > "0" &&
                  joint.layer[0] <= "9"
                )
                  valid++;
            return valid != 0;
          }

          // not a wildcard seek an available exact match
          if (!found) {
            let i = 0;
            while (!found && i < this.joints.length) {
              let j = 0;
              while (!found && j < models_with_available_joints.length) {
                let model = models_with_available_joints[j++];
                let k = 0;
                while (!found && k < model.joints.length) {
                  let joint = model.joints[k++];
                  if (joint.available && joint.model.category != 2) {
                    found = joint.layer == this.joints[i].layer;
                    if (found) {
                      found = joint.model.category != this.category;
                      /*
                                        if ( joint        . name . indexOf ( 'female' ) >= 0 &&
                                             joints [ i ] . name . indexOf ( 'female' ) >= 0 )
                                            return true
                                        */
                    }
                  }
                }
              }
              i++;
            }
          }

          // if no exact match is available look for available wildcards
          i = 0;
          while (!found && i < models_with_available_joints.length) {
            let model = models_with_available_joints[i++];

            // wildcards only can have 2 joints
            if (model.joints.length > 1) {
              let joint = model.joints[0];
              if (joint.layer == "*") {
                let other_joint = model.joints[1];
                if (joint.available || other_joint.available) {
                  if (!joint.available) {
                    joint = model.joints[1];
                    other_joint = model.joints[0];
                  }
                  if (!other_joint.available) {
                    let layer = other_joint.connected.layer;
                    // do i have a joint of this exact layer
                    let j = 0;
                    while (!found && j < this.joints.length) {
                      let plug_joint = this.joints[j++];
                      found = plug_joint.available && plug_joint.layer == layer;
                    }
                  }
                }
              }
            }
          }
          return found;
        }
        get_flag_mesh_list(args) {
          let flag_list = [];
          this.mesh.traverse((mesh) => {
            let splits = mesh.name.toLowerCase().split(",");
            if (splits[0].toLowerCase().startsWith("flag")) {
              flag_list.push(mesh);
            }
          });
          return flag_list;
        }
        get_flag_color_list(args) {
          let flag_list = [];
          this.mesh.traverse((mesh) => {
            let splits = mesh.name.toLowerCase().split(",");
            if (splits[0].toLowerCase().startsWith("flag")) {
              flag_list.push(mesh.material.color.getHexString());
            }
          });
          return flag_list;
        }
      }
      class Outliner {
        constructor(args) {
          let width = 64;
          let height = 64;

          if (args) {
            if ("width" in args) width = args.width;
            if ("height" in args) height = args.height;
          }

          this.render_target = new THREE.WebGLRenderTarget(width, height);

          this.mesh = new THREE.Mesh(
            new THREE.PlaneGeometry(2, 2),
            new THREE.ShaderMaterial({
              vertexShader: `
                            varying vec2 UV ;
                            
                            void main() {
                                UV = uv ;
                                gl_Position = vec4 ( position , 1. ) ;
                            }`,
              fragmentShader: `
                            uniform sampler2D source_texture ;
                            uniform vec2      resolution       ;
                            
                            void main() { 
                                vec2  uv = gl_FragCoord.xy / resolution     ;
                                float su = 1. / resolution . x ;
                                float sv = 1. / resolution . y ;

                                vec4 Color  = texture2D ( source_texture , uv ) ;
                                if ( texture2D ( source_texture , uv ) . a == 0. ) {
                                    if ( texture2D ( source_texture , uv + vec2 (   0. , - sv ) ) . a != 0. ) {
                                        Color = vec4 ( 1. , 1. , 0. , 1. ) ;
                                    }
                                    if ( texture2D ( source_texture , uv + vec2 (   su ,   0. ) ) . a != 0. ) {
                                        Color = vec4 ( 1. , 1. , 0. , 1. ) ;
                                    }
                                    if ( texture2D ( source_texture , uv + vec2 (   0. ,   sv ) ) . a != 0. ) {
                                        Color = vec4 ( 1. , 1. , 0. , 1. ) ;
                                    }
                                    if ( texture2D ( source_texture , uv + vec2 ( - su ,   0. ) ) . a != 0. ) {
                                        Color = vec4 ( 1. , 1. , 0. , 1. ) ;
                                    }
                                }
                                
                                gl_FragColor = Color ;
                            }`,
            })
          );
        }
        set_size(args) {
          this.render_target.setSize(args.width / 1, args.height / 1);
        }
        outline(args) {
          if (!args) return null;
          if (!"render_target" in args) return null;

          this.mesh.material.uniforms["source_texture"] = {
            value: args.render_target.texture,
          };
          this.mesh.material.uniforms["resolution"] = {
            value: new THREE.Vector2(
              args.render_target.width,
              args.render_target.height
            ),
          };
          //this . mesh . material . uniformsNeedUpdate = true

          renderer.setRenderTarget(this.render_target);
          scene.add(this.mesh);
          renderer.render(scene, camera);
          scene.remove(this.mesh);

          let render_target_pixels = new Uint8ClampedArray(
            4 * this.render_target.width * this.render_target.height
          );
          renderer.readRenderTargetPixels(
            this.render_target,
            0,
            0,
            this.render_target.width,
            this.render_target.height,
            render_target_pixels
          );
          let flipped_render_target_pixels = new Uint8ClampedArray(
            4 * this.render_target.width * this.render_target.height
          );
          for (let y = 0; y < this.render_target.height; y++) {
            for (let x = 0; x < this.render_target.width; x++) {
              let si = y * this.render_target.width * 4 + x * 4;
              let di =
                (this.render_target.height - y) * this.render_target.width * 4 +
                x * 4;
              flipped_render_target_pixels[di + 0] =
                render_target_pixels[si + 0];
              flipped_render_target_pixels[di + 1] =
                render_target_pixels[si + 1];
              flipped_render_target_pixels[di + 2] =
                render_target_pixels[si + 2];
              flipped_render_target_pixels[di + 3] =
                render_target_pixels[si + 3];
            }
          }

          let byte_map = [];
          let bmrs = this.render_target.width + 2;
          let bmi = 0;
          for (let y = -1; y < this.render_target.height + 1; y++) {
            for (let x = -1; x < this.render_target.width + 1; x++) {
              if (
                y == -1 ||
                y == this.render_target.height ||
                x == -1 ||
                x == this.render_target.width
              )
                byte_map[bmi++] = 0;
              else {
                let i = y * this.render_target.width * 4 + x * 4;
                if (
                  flipped_render_target_pixels[i + 0] == 255 &&
                  flipped_render_target_pixels[i + 1] == 255 &&
                  flipped_render_target_pixels[i + 2] == 0 &&
                  flipped_render_target_pixels[i + 3] == 255
                ) {
                  byte_map[bmi++] = 1;
                } else byte_map[bmi++] = 0;
              }
            }
          }

          let pixels_found;
          let strokes = [];
          let stroke;
          do {
            pixels_found = false;
            for (let y = 0; y < this.render_target.height; y++) {
              for (let x = 0; x < this.render_target.width; x++) {
                let i = y * bmrs + x;
                if (byte_map[i]) {
                  pixels_found = true;
                  byte_map[i] = 0;

                  stroke = [{ x: x, y: y }];
                  strokes.push(stroke);

                  // extract contour
                  let xx = x;
                  let yy = y;
                  let b;
                  do {
                    let ii = yy * bmrs + xx;
                    if ((b = byte_map[ii - bmrs])) yy--;
                    else if ((b = byte_map[ii - bmrs + 1])) {
                      yy--;
                      xx++;
                    } else if ((b = byte_map[ii + 1])) xx++;
                    else if ((b = byte_map[ii + bmrs + 1])) {
                      yy++;
                      xx++;
                    } else if ((b = byte_map[ii + bmrs])) yy++;
                    else if ((b = byte_map[ii + bmrs - 1])) {
                      yy++;
                      xx--;
                    } else if ((b = byte_map[ii - 1])) xx--;
                    else if ((b = byte_map[ii - bmrs - 1])) {
                      yy--;
                      xx--;
                    }
                    if (b) {
                      byte_map[yy * bmrs + xx] = 0;
                      stroke.push({ x: xx, y: yy });
                    }
                  } while (b);
                }
              }
            }
          } while (pixels_found);

          //let imageData = new ImageData ( flipped_render_target_pixels , this . render_target . width , this . render_target . height )
          //context . putImageData ( imageData , 0 , 0 )

          context.lineWidth = 2;

          context.strokeStyle = "#80c0ff";
          //context . setLineDash ( [ 8 , 8 ] )
          for (stroke of strokes) {
            context.beginPath();
            context.moveTo(stroke[0].x, stroke[0].y);
            for (let i = 1; i < stroke.length; i++)
              context.lineTo(stroke[i].x, stroke[i].y);
            context.stroke();
          }
          //context . setLineDash ( [] )

          context.strokeStyle = "#406080";
          context.setLineDash([4, 8]);
          for (stroke of strokes) {
            context.beginPath();
            context.moveTo(stroke[0].x, stroke[0].y);
            for (let i = 1; i < stroke.length; i++)
              context.lineTo(stroke[i].x, stroke[i].y);
            context.stroke();
          }
          context.setLineDash([]);
        }
      }
      class Thumbnailer {
        static thumbnail_size = 256;

        constructor(args) {
          this.scene = new THREE.Scene();
          this.scene.background = null;
          this.camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);

          let ambientLight = new THREE.AmbientLight(0x808080);
          this.scene.add(ambientLight);

          let dirLightGroup = new THREE.Group();
          this.scene.add(dirLightGroup);

          let rightDirLight = new THREE.DirectionalLight(0xffffff);
          rightDirLight.position.set(3, 12, 17);
          rightDirLight.castShadow = true;
          rightDirLight.shadow.camera.near = 0.1;
          rightDirLight.shadow.camera.far = 500;
          rightDirLight.shadow.camera.right = 17;
          rightDirLight.shadow.camera.left = -17;
          rightDirLight.shadow.camera.top = 17;
          rightDirLight.shadow.camera.bottom = -17;
          rightDirLight.shadow.mapSize.width = 2048;
          rightDirLight.shadow.mapSize.height = 2048;
          rightDirLight.shadow.radius = 4;
          rightDirLight.shadow.bias = -0.0005;
          dirLightGroup.add(rightDirLight);

          let leftDirLight = new THREE.DirectionalLight(0xffffff);
          leftDirLight.position.set(-3, 12, -17);
          leftDirLight.castShadow = true;
          leftDirLight.shadow.camera.near = 0.1;
          leftDirLight.shadow.camera.far = 500;
          leftDirLight.shadow.camera.right = 17;
          leftDirLight.shadow.camera.left = -17;
          leftDirLight.shadow.camera.top = 17;
          leftDirLight.shadow.camera.bottom = -17;
          leftDirLight.shadow.mapSize.width = 2048;
          leftDirLight.shadow.mapSize.height = 2048;
          leftDirLight.shadow.radius = 4;
          leftDirLight.shadow.bias = -0.0005;
          dirLightGroup.add(leftDirLight);

          this.renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: false,
          });
          this.renderer.setSize(
            Thumbnailer.thumbnail_size,
            Thumbnailer.thumbnail_size
          );
        }
        nail_it(args) {
          let clone = args.model.mesh.clone();

          clone.traverse((mesh) => {
            mesh.visible = true;
            if (mesh.name.toLowerCase().startsWith("roof_canopy"))
              mesh.visible = args.model.roof_canopy_mesh.visible;
            if (mesh.name.toLowerCase().startsWith("roof_poly"))
              mesh.visible = args.model.roof_poly_mesh.visible;
            if (mesh.name.toLowerCase().startsWith("joint"))
              if ("material" in mesh) {
                mesh.material.transparent = true;
                mesh.material.opacity = 0;
              }
          });

          this.scene.add(clone);
          clone.rotation.y += Math.PI;

          const box = new THREE.Box3().setFromObject(clone);
          const sphere = new THREE.Sphere();
          box.getBoundingSphere(sphere);
          let d = 1.75 * sphere.radius;
          if (d == 0) d = 150;
          this.camera.position.set(
            box.min.x + (box.max.x - box.min.x) / 2 - d,
            box.min.y + (box.max.y - box.min.y) / 2 + d / 2,
            box.min.z + (box.max.z - box.min.z) / 2 - d
          );
          this.camera.lookAt(
            box.min.x + (box.max.x - box.min.x) / 2,
            box.min.y + (box.max.y - box.min.y) / 2,
            box.min.z + (box.max.z - box.min.z) / 2
          );

          this.renderer.render(this.scene, this.camera);

          this.scene.remove(clone);

          let canvas = document.createElement("canvas");
          canvas.width = Thumbnailer.thumbnail_size;
          canvas.height = Thumbnailer.thumbnail_size;
          let context = canvas.getContext("2d");
          context.clearRect(0, 0, canvas.width, canvas.height);
          context.drawImage(this.renderer.domElement, 0, 0);

          return canvas.toDataURL("image/png");
        }
      }

      const Can_connect = (args) => {
        //for ( let box3 of box3s ) scene . remove ( box3 )

        const plug_joint = args.plug_joint;
        const host_joint = args.host_joint;

        let plug_mesh = plug_joint.model.mesh.clone();
        /*
            const yaw = Lookup_yaw ( { 
                host_model_yaw       : host_joint . model . yaw , 
                host_joint_direction : host_joint . direction , 
                plug_joint_direction : plug_joint . direction } )
            plug_mesh . rotation . y = yaw * Deg2Rad
            
            let pjp = new THREE . Vector3 ()
            plug_joint . getWorldPosition ( pjp )
            let mjp = new THREE . Vector3 ()
            plug_mesh . getWorldPosition ( mjp )
            let p   = new THREE . Vector3 ()
            p . subVectors ( mjp , pjp )
            let hjp = new THREE . Vector3 ()
            host_joint . getWorldPosition ( hjp )
            p . add ( hjp )
            if ( p . y < 0 ) p . y = 0
            plug_mesh . position . copy ( p )
            plug_mesh . scale . set ( .75, .75 , .75 )
            */
        plug_mesh.scale.set(0.75, 0.75, 0.75);
        let plug_box3 = new THREE.Box3().setFromObject(plug_mesh);
        //const plug_box3Helper = new THREE . Box3Helper ( plug_box3 , 0xff0000 )
        //scene . add  ( plug_box3Helper )
        //box3s . push ( plug_box3Helper )

        for (let model of models_with_available_joints) {
          if (model != host_joint.model) {
            let m = model.mesh.clone();
            let p = new THREE.Vector3();
            let q = new THREE.Quaternion();
            model.mesh.getWorldQuaternion(q);
            m.quaternion.copy(q);
            model.mesh.getWorldPosition(p);
            m.position.copy(p);
            m.scale.set(0.75, 0.75, 0.75);
            const model_box3 = new THREE.Box3().setFromObject(m);
            //const box3Helper = new THREE . Box3Helper ( model_box3 , 0x0000ff )
            //scene . add  ( box3Helper )
            //box3s . push ( box3Helper )

            if (plug_box3.intersectsBox(model_box3)) {
              return false;
            }
          }
        }

        return true;
      };
      const Show_touched_fences = (args) => {
        let plug_joint = args.joint;
        let mesh = args.mesh;

        let m = plug_joint.clone();
        let p = new THREE.Vector3();
        let q = new THREE.Quaternion();
        plug_joint.getWorldQuaternion(q);
        m.quaternion.copy(q);
        plug_joint.getWorldPosition(p);
        m.position.copy(p);

        let plug_box3 = new THREE.Box3().setFromObject(m);
        //scene . add ( new THREE . Box3Helper ( plug_box3 , 0xffff00 ) )

        mesh.traverse((mesh) => {
          if (mesh.name.toLowerCase().indexOf("fence") > -1) {
            let m = mesh.clone();
            let p = new THREE.Vector3();
            let q = new THREE.Quaternion();
            mesh.getWorldQuaternion(q);
            m.quaternion.copy(q);
            mesh.getWorldPosition(p);
            m.position.copy(p);

            let host_box3 = new THREE.Box3().setFromObject(m);
            //scene . add ( new THREE . Box3Helper ( host_box3 , 0x0000ff ) )

            if (plug_box3.intersectsBox(host_box3)) {
              mesh.visible = true;
            }
          }
        });
      };
      const Hide_touched_fences = (args) => {
        let plug_joint = args.toucher;
        let host_joint = args.parent;

        let m = plug_joint.clone();
        let p = new THREE.Vector3();
        let q = new THREE.Quaternion();
        plug_joint.getWorldQuaternion(q);
        m.quaternion.copy(q);
        plug_joint.getWorldPosition(p);
        m.position.copy(p);

        let plug_box3 = new THREE.Box3().setFromObject(m);
        //scene . add ( new THREE . Box3Helper ( plug_box3 , 0xffff00 ) )

        host_joint.model.mesh.traverse((mesh) => {
          //if ( ! mesh . name . toLowerCase () . startsWith ( 'joint' ) ) {
          if (mesh.name.toLowerCase().indexOf("fence") > -1) {
            let m = mesh.clone();
            let p = new THREE.Vector3();
            let q = new THREE.Quaternion();
            mesh.getWorldQuaternion(q);
            m.quaternion.copy(q);
            mesh.getWorldPosition(p);
            m.position.copy(p);

            let host_box3 = new THREE.Box3().setFromObject(m);
            //scene . add ( new THREE . Box3Helper ( host_box3 , 0x0000ff ) )

            if (plug_box3.intersectsBox(host_box3)) {
              mesh.visible = false;
            }
          }
          //}
        });
      };
      const Connect_joints = (args) => {
        let host_joint = args.joint_1;
        let plug_joint = args.joint_2;

        host_joint.available = false;
        plug_joint.available = false;
        plug_joint.connected = host_joint;
        host_joint.connected = plug_joint;

        if (host_joint.excluder_layer)
          for (let joint of host_joint.model.joints)
            if (joint.exclusion_layer == host_joint.excluder_layer) {
              joint.available = false;
            }

        if (
          host_joint.model.category == 0 &&
          host_joint.model.children_index < 2 &&
          plug_joint.model.category == 1 &&
          plug_joint.model.children_index > 3
        ) {
          let found = false;
          let i = 0;
          let beam_swing_joint;
          while (!found && i < plug_joint.model.joints.length) {
            beam_swing_joint = plug_joint.model.joints[i++];
            found = "ds" == beam_swing_joint.layer;
          }
          if (found) beam_swing_joint.available = false;
        }

        Hide_touched_fences({ parent: host_joint, toucher: plug_joint });
        Hide_touched_fences({ parent: plug_joint, toucher: host_joint });
      };
      const Tik = (args) => {
        let delta = clock.getDelta();
        shader_time += delta;

        context.lineDashOffset = dashOffset--;

        orbitControls.update();
        if (window.syncWorldRotationWithCamera) syncWorldRotationWithCamera();

        zum_slider.value = camera.position
          .clone()
          .sub(orbitControls.target)
          .length();

        context.clearRect(0, 0, canvas.width, canvas.height);

        if (joint_image_frame++ >= joint_image_frames - 1)
          joint_image_frame = 0;

        // highlight available hosts joints
        //for ( let box3 of box3s ) scene . remove ( box3 )
        if (Mode.plugging == Mode.mode) {
          let size = joint_image.height / 2;
          for (let model of models_with_available_joints)
            for (let joint of model.joints) {
              let we_gud = false;
              if (joint.available) {
                if (
                  joint.name.indexOf("_no_tube_slides") > -1 &&
                  plug_joint.model.tubular
                ) {
                } else {
                  if (joint.layer == plug_joint.layer) {
                    if (joint.layer != "*")
                      we_gud =
                        joint.model.category != plug_joint.model.category;
                  } else {
                    if (joint.layer == "*") {
                      if (model.joints.length > 1) {
                        let connected_layer;
                        if (joint == model.joints[0])
                          connected_layer = model.joints[1].connected.layer;
                        else connected_layer = model.joints[0].connected.layer;
                        we_gud = connected_layer == plug_joint.layer;
                      }
                    } else {
                      if (plug_joint.layer == "*") {
                        if (plug_joint.model.joints.length == 1)
                          we_gud =
                            joint.layer[0] >= "0" && joint.layer[0] <= "9";
                        else
                          we_gud =
                            joint.layer[0] > "0" && joint.layer[0] <= "9";
                      }
                    }
                  }
                }
              }
              if (we_gud) {
                let show_joint = true;

                if (plug_joint.name.startsWith("joint_pole,")) {
                  show_joint = joint.name.startsWith("joint_pole_female");
                } else if (plug_joint.name.startsWith("joint_c"))
                  show_joint =
                    joint.name.startsWith("joint,") ||
                    joint.name.startsWith("joint_pole");

                if (
                  Can_connect({ plug_joint: plug_joint, host_joint: joint }) &&
                  show_joint
                ) {
                  let joint_position = Ddd2dd({ object3D: joint });
                  joint.x = joint_position.x - size / 2;
                  joint.y = joint_position.y - size / 2;

                  context.drawImage(
                    joint_image,
                    joint_image_frame * joint_image.height,
                    0,
                    joint_image.height,
                    joint_image.height,
                    joint.x,
                    joint.y,
                    size,
                    size
                  );
                }
              }
            }
        }

        // rotate the plug
        if (
          /*false ) { //*/ Mode.placing == Mode.mode ||
          (Mode.plugging == Mode.mode && plug_model)
        ) {
          mouse.x = (Pointers.position.x / canvas.width) * 2 - 1;
          mouse.y = (-Pointers.position.y / canvas.height) * 2 + 1;
          raycaster.setFromCamera(mouse, camera);
          let intersectables = picked_meshes.slice();
          intersectables.push(skybox.mesh);
          let intersection_objects = raycaster.intersectObjects(
            intersectables,
            true
          );
          if (intersection_objects.length > 0) {
            let i = intersection_objects[0];
            let io = i.object;
            let ip = i.point;

            //						if ( Mode . plugging == Mode . mode ) {
            host_joint = Find_closest_available_joint({
              position: Pointers.position,
            });
            if (host_joint != null) {
              if (
                host_joint.layer == "s" ||
                host_joint.layer == "sh" ||
                host_joint.layer == "ds"
              ) {
                scene.remove(plug_model.mesh);
                // plug_model is a swing
                // assuming only beams have available layer 's' joints
                plug_model.morph({ layer: host_joint.model.joints[0].layer });
                plug_joint = plug_model.joints[plug_joint_index];
                scene.add(plug_model.mesh);
              }

              plug_model.mesh.rotation.y =
                Lookup_yaw({
                  host_model_yaw: host_joint.model.yaw,
                  host_joint_direction: host_joint.direction,
                  plug_joint_direction: plug_joint.direction,
                }) * Deg2Rad;

              if (host_joint.layer == "handle") {
                plug_model.mesh.traverse((mesh) => {
                  if (mesh.name.indexOf("_colorize_") != -1)
                    mesh.rotation.x = host_joint.model.slope * Deg2Rad;
                });
              }

              let pjp = new THREE.Vector3();
              plug_joint.getWorldPosition(pjp);
              let mjp = new THREE.Vector3();
              plug_model.mesh.getWorldPosition(mjp);
              let p = new THREE.Vector3();
              p.subVectors(mjp, pjp);

              if (
                Pointers.position.x > host_joint.x &&
                Pointers.position.x < host_joint.x + joint_image.height / 2 &&
                Pointers.position.y > host_joint.y &&
                Pointers.position.y < host_joint.y + joint_image.height / 2
              ) {
                let pp = new THREE.Vector3();
                host_joint.getWorldPosition(pp);
                p.add(pp);
              } else p.add(ip);

              if (p.y < 0) p.y = 0;
              plug_model.mesh.position.copy(p);
            } else {
              plug_model.mesh.rotation.y = plug_model.yaw * Deg2Rad;
              plug_model.mesh.position.copy(ip);
            }
            //						}
          }
        }

        Render();
      };
      const Pointer_down = (args) => {
        mouse.x = (Pointers.position.x / canvas.width) * 2 - 1;
        mouse.y = (-Pointers.position.y / canvas.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        let intersectables = [];
        switch (Mode.mode) {
          case Mode.normal:
            {
              let intersection_objects = raycaster.intersectObjects(
                picked_meshes,
                true
              );
              if (intersection_objects.length > 0) {
                intersection_object = intersection_objects[0];
                intersection_point.copy(intersection_object.point);
                intersection_mesh = intersection_object.object;

                picked_mesh = intersection_objects[0].object;
                if ("model" in picked_mesh) {
                  for (let model of Model.instances) model.selected = false;

                  picked_mesh.model.selected = true;
                }

                let splits = picked_mesh.name.toLowerCase().split(",");

                if (splits[0].toLowerCase().startsWith("flag")) {
                  $("#custom-controls-delete").hide();
                  $(".custom-controls-line").hide();

                  let htmlStr = "";
                  for (
                    let color_index = 1;
                    color_index < splits.length;
                    color_index++
                  ){
                    if(splits[color_index] !== 'tricolors')
                      htmlStr +=
                        '<div onclick = "Change_flag_color ( 0x' +
                        splits[color_index].substring(1) +
                        ')" class="custom-controls-color custom-controls-poly-color" style="background-color: ' +
                        splits[color_index] +
                        '"></div>';
                  }

                  $(".custom-controls-color-container").html(htmlStr);

                  $(".custom-controls").css("display", "inline-flex");
                  $(".custom-controls").css(
                    "left",
                    `calc(50vw - ${$(".custom-controls").width() / 2}px)`
                  );
                  $(".custom-controls-roof").hide();
                } else if (splits[0].toLowerCase().startsWith("roof")) {
                  if (
                    picked_mesh.model.roof_poly_mesh &&
                    picked_mesh.model.roof_canopy_mesh
                  ) {
                    $("#custom-controls-delete").hide();
                    $(".custom-controls-line").hide();
                    $(".custom-controls-color-container").html("");
                    $(".custom-controls").hide();

                    $(".custom-controls-roof").css("display", "flex");
                    $(".custom-controls-roof").css("flex-direction", "column");
                    $(".custom-controls-roof").show();
                    $(".custom-controls-line").show();

                    let htmlStr = "";
                    let splits_canopy = picked_mesh.model.roof_canopy_mesh.name
                      .toLowerCase()
                      .split(",");
                    // Reorder colors to match static HTML: white, blue, red, gray, yellow, then any remaining colors
                    const colorOrder = [1, 2, 3, 4, 6, 5]; // Skip index 0, reorder: white(1), blue(2), red(3), gray(5), yellow(4)
                    const processedIndexes = new Set([0, ...colorOrder]); // Track processed indexes
                    
                    // First process the reordered colors
                    for (let i = 0; i < colorOrder.length; i++) {
                      const color_index = colorOrder[i];
                      if (color_index >= splits_canopy.length) continue;
                      if (splits_canopy[color_index] == "tricolors") {
                        htmlStr +=
                          '<div onclick = "Change_roof_canopy_color ( `tricolors` )" class="custom-controls-color custom-controls-poly-color" index="' +
                          color_index +
                          '"';
                        htmlStr +=
                          'style="background-color: ' +
                          splits_canopy[color_index] +
                          '">';
                        htmlStr +=
                          '<img src="images/image_ae45a138.png">';
                        htmlStr += "</div>";
                      } else {
                        htmlStr +=
                          '<div onclick = "Change_roof_canopy_color ( 0x' +
                          splits_canopy[color_index].substring(1) +
                          ')" class="custom-controls-color custom-controls-poly-color" index="' +
                          color_index +
                          '"';
                        htmlStr +=
                          'style="background-color: ' +
                          splits_canopy[color_index] +
                          '">';
                        htmlStr += "</div>";
                      }
                    }
                    
                    // Then process any remaining colors (like tricolors at index 6, etc.)
                    for (let color_index = 1; color_index < splits_canopy.length; color_index++) {
                      if (processedIndexes.has(color_index)) continue; // Skip already processed colors
                      
                      if (splits_canopy[color_index] == "tricolors") {
                        htmlStr +=
                          '<div onclick = "Change_roof_canopy_color ( `tricolors` )" class="custom-controls-color custom-controls-poly-color" index="' +
                          color_index +
                          '"';
                        htmlStr +=
                          'style="background-color: ' +
                          splits_canopy[color_index] +
                          '">';
                        htmlStr +=
                          '<img src="images/image_6a0cd279.png">';
                        htmlStr += "</div>";
                      } else {
                        htmlStr +=
                          '<div onclick = "Change_roof_canopy_color ( 0x' +
                          splits_canopy[color_index].substring(1) +
                          ')" class="custom-controls-color custom-controls-poly-color" index="' +
                          color_index +
                          '"';
                        htmlStr +=
                          'style="background-color: ' +
                          splits_canopy[color_index] +
                          '">';
                        htmlStr += "</div>";
                      }
                    }
                    
                    $(".custom-controls-color-canopy").html(htmlStr);

                    htmlStr = "";
                    let splits_poly = picked_mesh.model.roof_poly_mesh.name
                      .toLowerCase()
                      .split(",");
                    // Reorder colors to match static HTML: white, blue, red, gray, yellow
                    const polyColorOrder = [1, 2, 3, 4, 6, 5]; // Skip index 0, reorder: white(1), blue(2), red(3), gray(5), yellow(4)
                    
                    for (let i = 0; i < polyColorOrder.length; i++) {
                      const color_index = polyColorOrder[i];
                      if (color_index >= splits_poly.length) continue;
                      if (splits_poly[color_index] != "tricolor") {
                        htmlStr +=
                          '<div onclick = "Change_roof_poly_color ( 0x' +
                          splits_poly[color_index].substring(1) +
                          ')" class="custom-controls-color custom-controls-poly-color" index="' +
                          color_index +
                          '"';
                        if (splits_poly[color_index] == "tricolor")
                          htmlStr +=
                            '><img src="images/image_ae45a138.png">';
                        else
                          htmlStr +=
                            'style="background-color: ' +
                            splits_poly[color_index] +
                            '">';
                        htmlStr += "</div>";
                      }
                    }
                    $(".custom-controls-color-poly").html(htmlStr);

                  } else {
                    $("#custom-controls-delete").hide();
                    $(".custom-controls-line").hide();
                    $(".custom-controls-roof").hide();

                    let htmlStr = "";
                    let splits_canopy = picked_mesh.model.roof_canopy_mesh.name
                      .toLowerCase()
                      .split(",");
                    // Reorder colors to match static HTML: white, blue, red, gray, yellow, then any remaining colors
                    const colorOrder = [1, 2, 3, 4, 6, 5]; // Skip index 0, reorder: white(1), blue(2), red(3), gray(5), yellow(4)
                    const processedIndexes = new Set([0, ...colorOrder]); // Track processed indexes
                    
                    // First process the reordered colors
                    for (let i = 0; i < colorOrder.length; i++) {
                      const color_index = colorOrder[i];
                      if (color_index >= splits_canopy.length) continue;
                      if (splits_canopy[color_index] == "tricolors") {
                        htmlStr +=
                          '<div onclick = "Change_roof_canopy_color ( `tricolors` )" class="custom-controls-color custom-controls-poly-color" index="' +
                          color_index +
                          '"';
                        htmlStr +=
                          'style="background-color: ' +
                          splits_canopy[color_index] +
                          '">';
                        htmlStr +=
                          '<img src="images/image_ae45a138.png">';
                        htmlStr += "</div>";
                      } else {
                        htmlStr +=
                          '<div onclick = "Change_roof_canopy_color ( 0x' +
                          splits_canopy[color_index].substring(1) +
                          ')" class="custom-controls-color custom-controls-poly-color" index="' +
                          color_index +
                          '"';
                        htmlStr +=
                          'style="background-color: ' +
                          splits_canopy[color_index] +
                          '">';
                        htmlStr += "</div>";
                      }
                    }
                    $(".custom-controls-color-container").html(htmlStr);

                    $(".custom-controls").css("display", "inline-flex");
                    $(".custom-controls").css(
                      "left",
                      `calc(50vw - ${$(".custom-controls").width() / 2}px)`
                    );
                  }
                } else {
                  $("#custom-controls-delete").show();

                  let splits_2 = picked_mesh.model.mesh.children[0].name
                    .toLowerCase()
                    .split(",");

                  if(splits_2 == "summitglb"){
                    splits_2 = ['summitglb', '#004983', '#01664b', '#93293b', '#5b5e67'];
                  }

                  if (splits_2.length > 1) $(".custom-controls-line").show();
                  else $(".custom-controls-line").hide();

                  let htmlStr = "";
                  for (
                    let color_index = 1;
                    color_index < splits_2.length;
                    color_index++
                  )
                    htmlStr +=
                      '<div onclick = "Colorize ( 0x' +
                      splits_2[color_index].substring(1) +
                      ')" class="custom-controls-color custom-controls-poly-color" style="background-color: ' +
                      splits_2[color_index] +
                      '"></div>';
                  $(".custom-controls-color-container").html(htmlStr);

                  $(".custom-controls").css("display", "inline-flex");
                  $(".custom-controls").css(
                    "left",
                    `calc(50vw - ${$(".custom-controls").width() / 2}px)`
                  );
                  $(".custom-controls-roof").hide();
                }
              } else {
                for (let model of Model.instances) model.selected = false;
                picked_mesh = null;
                Hide_options();
              }
            }
            break;
          case Mode.placing:
            {
              models_with_available_joints.push(plug_model);
              picked_meshes.push(plug_model.mesh);
              plug_model = null;
              plug_joint_index = -1;
              Mode.mode = Mode.normal;

              Show_items();
              // Set_up_email ()
              Update_measurements();
            }
            break;
          case Mode.plugging:
            {
              if (
                Can_connect({
                  plug_joint: plug_joint,
                  host_joint: host_joint,
                }) &&
                Pointers.position.x > host_joint.x &&
                Pointers.position.x < host_joint.x + joint_image.height / 2 &&
                Pointers.position.y > host_joint.y &&
                Pointers.position.y < host_joint.y + joint_image.height / 2
              ) {
                // undo
                blueprint.add_snapshot();

                // orient the model & mesh
                plug_model.yaw = Lookup_yaw({
                  host_model_yaw: host_joint.model.yaw,
                  host_joint_direction: host_joint.direction,
                  plug_joint_direction: plug_joint.direction,
                });
                plug_model.mesh.rotation.y = plug_model.yaw * Deg2Rad;

                let pjp = new THREE.Vector3();
                plug_joint.getWorldPosition(pjp);
                let mjp = new THREE.Vector3();
                plug_model.mesh.getWorldPosition(mjp);
                let p = new THREE.Vector3();
                p.subVectors(mjp, pjp);
                let hjp = new THREE.Vector3();
                host_joint.getWorldPosition(hjp);
                p.add(hjp);

                if (p.y < 0) p.y = 0;
                plug_model.mesh.position.copy(p);

                // actually connect the joints
                Connect_joints({ joint_1: host_joint, joint_2: plug_joint });

                models_with_available_joints.push(plug_model);
                picked_meshes.push(plug_model.mesh);
                plug_model = null;
                plug_joint = null;
                Mode.mode = Mode.normal;
                /*
                        if ( box3Helper ) scene . remove ( box3Helper )
                        box = new THREE . Box3 ()
                        for ( let mesh of picked_meshes )
                            box . expandByObject ( mesh )
                        box3Helper = new THREE . Box3Helper ( box , 0xffff00 )
                        scene . add ( box3Helper )
                        */
                Show_items();
                // Set_up_email ()
                Update_measurements();
              }
            }
            break;
        }
      };

      zum_slider.oninput = (args) => {
        camera.position.copy(
          camera.position
            .clone()
            .sub(orbitControls.target)
            .normalize()
            .multiplyScalar(zum_slider.value)
        );
        orbitControls.update();
        if (window.syncWorldRotationWithCamera) syncWorldRotationWithCamera();
      };
      const Zumin = (args) => {
        if (--zum_slider.value < 1) zum_slider.value = 1;
        camera.position.copy(
          camera.position
            .clone()
            .sub(orbitControls.target)
            .normalize()
            .multiplyScalar(zum_slider.value)
        );
        orbitControls.update();
        if (window.syncWorldRotationWithCamera) syncWorldRotationWithCamera();
      };
      const Zumout = (args) => {
        if (++zum_slider.value > 49) zum_slider.value = 49;
        camera.position.copy(
          camera.position
            .clone()
            .sub(orbitControls.target)
            .normalize()
            .multiplyScalar(zum_slider.value)
        );
        orbitControls.update();
        if (window.syncWorldRotationWithCamera) syncWorldRotationWithCamera();
      };
      mulch_length_slider.oninput = (args) => {
        if (mulch) mulch.build({ depth: parseInt(mulch_length_slider.value) });
      };
      mulch_width_slider.oninput = (args) => {
        if (mulch) mulch.build({ width: parseInt(mulch_width_slider.value) });
      };

      const Show_info = (args) => {
        let n = picked_meshes.length;
        info_dialog_title_label.innerText = n + (n == 1 ? " part." : " parts.");
        let html = '<table id = "product_table"><tbody id = "info_body">';
        part_list = [];
        for (let picked_mesh of picked_meshes) {
          let model = picked_mesh.model;

          html += "<tr>";

          let thumbnail = thumbnailer.nail_it({ model: model });
          let name =
            Categories[model.category].children[model.children_index].name;
          let ruf = "";
          if (model.roof_canopy_mesh)
            if (model.roof_canopy_mesh.visible)
              ruf =
                Color2Name(model.roof_canopy_mesh.material.color) + " canopy";
          if (ruf == "" && model.roof_poly_mesh) ruf = "Green poly";
          let colorized_color_name = "";

          model.mesh.traverse((mesh) => {
            if (mesh.name.indexOf("_colorize_") != -1)
              colorized_color_name =
                Color2Name(new THREE.Color(mesh.material.color)) +
                " base color";
          });

          if (model.colorized) {
            colorized_color_name = Color2Name(new THREE.Color(model.colorized));
            colorized_color_name += " base color";
          }

          let options = [];
          if (ruf) options.push(ruf);
          if (colorized_color_name.length > 0 && name.indexOf("floor") < 0)
            options.push(colorized_color_name);

          // look for flags
          let flag_list = [];
          model.mesh.traverse((mesh) => {
            let splits = mesh.name.toLowerCase().split(",");
            if (splits[0].toLowerCase().startsWith("flag")) {
              let found = false;
              let i = 0;
              let color_name = Color2Name(mesh.material.color);
              while (!found && i < flag_list.length) {
                found = color_name == flag_list[i++].color_name;
              }
              if (found) {
                flag_list[--i].count++;
              } else
                flag_list.push({
                  count: 1,
                  color_name: color_name,
                });
            }
          });
          for (let flag of flag_list)
            if (flag.count > 0) {
              let s = flag.count + " " + flag.color_name;
              if (flag.count == 1) s += " flag";
              else s += " flags";
              options.push(s);
            }

          part_list.push({
            thumbnail: thumbnail,
            thumbnail_size: Thumbnailer.thumbnail_size,
            name: name,
            options: options,
          });

          html +=
            '<td style = "width : 33%;"><img style = "width : 128px ; height : 128px ;" src = "' +
            thumbnail +
            '"/></td>';
          html += "<td>" + name + "</td>";
          html += "<td>";
          for (let option of options) html += option + "<br>";
          html += "</td>";
          html += "</tr>";
        }
        html += "</table>";

        info_content.innerHTML = html;

        Resize_info_dialog();

        $("#info_dialog").show();
      };
      const Trash_picked_mesh = (args) => {
        // undo
        blueprint.add_snapshot();

        let model = picked_mesh.model;
        switch (model.category) {
          case 0:
            break;
          case 1:
            {
              // swing beam
              for (let joint of model.joints) {
                if (!joint.available && joint.connected) {
                  let connected_joint = joint.connected;
                  let connected_model = connected_joint.model;

                  if (joint.layer.startsWith("b")) {
                    connected_joint.available = true;
                  } else {
                    scene.remove(connected_model.mesh);

                    let index =
                      models_with_available_joints.indexOf(connected_model);
                    if (index != -1)
                      models_with_available_joints.splice(index, 1);

                    index = picked_meshes.indexOf(connected_model.mesh);
                    if (index != -1) picked_meshes.splice(index, 1);
                  }
                  joint.available = true;
                }
              }
            }
            break;
          case 2:
            break;
          case 3:
            break;
          case 4:
            {
              // entry
              for (let joint of model.joints) {
                if (!joint.available && joint.connected) {
                  let connected_joint = joint.connected;
                  let connected_model = connected_joint.model;

                  if (joint.layer.startsWith("handle")) {
                    scene.remove(connected_model.mesh);

                    let index =
                      models_with_available_joints.indexOf(connected_model);
                    if (index != -1)
                      models_with_available_joints.splice(index, 1);

                    index = picked_meshes.indexOf(connected_model.mesh);
                    if (index != -1) picked_meshes.splice(index, 1);
                  }
                }
              }
            }
            break;
          case 5:
            break;
          case 6:
            break;
        }

        scene.remove(model.mesh);

        let index = models_with_available_joints.indexOf(model);
        if (index != -1) models_with_available_joints.splice(index, 1);

        index = picked_meshes.indexOf(model.mesh);
        if (index != -1) picked_meshes.splice(index, 1);

        for (let joint of picked_mesh.model.joints)
          if (!joint.available) {
            let connected_joint = joint.connected;
            connected_joint.available = true;

            Show_touched_fences({
              joint: joint,
              mesh: connected_joint.model.mesh,
            });

            if (connected_joint.excluder_layer)
              for (let joint of connected_joint.model.joints)
                if (joint.exclusion_layer == connected_joint.excluder_layer) {
                  joint.available = true;
                }
          }

        Hide_options();
        Show_items();
        Update_measurements();
      };
      const Center = (args) => {
        if (!picked_meshes.length) return;

        const center = new THREE.Vector3();
        for (let mesh of picked_meshes) center.add(mesh.position);
        center.divideScalar(picked_meshes.length);

        for (let mesh of picked_meshes) {
          mesh.position.x -= center.x;
          mesh.position.z -= center.z;
        }
      };
      const Help = (args) => {
        instructions_dialog.style.display = "block";
      };
      const Resize_instructions_dialog = (args) => {
        let t = 0;
        let y;
        let h = Math.floor(innerHeight * 0.9);

        y = Math.floor(h * 0.04);
        instructions_dialog.style.padding = y + "px";
        t += y * 1;

        y = Math.floor(h * 0.1);
        instructions_dialog_title.style.height = y + "px";
        t += y;

        y = Math.floor(h * 0.6);
        instructions_content.style.height = y + "px";
        t += y;

        const cw = innerHeight / 2;

        product_list_cell.style.width = cw + "px";

        const d = 18;
        space_img.style.height = h / d + "px";
        esc_img.style.height = h / d + "px";

        product_list_img.style.height = h / d + "px";
        mulch_options_img.style.height = h / d + "px";

        center_camera_img.style.height = h / d + "px";
        background_img.style.height = h / d + "px";

        refresh_img.style.height = h / d + "px";
        size_img.style.height = h / d + "px";

        undo_img.style.height = h / d + "px";
        instructions_img.style.height = h / d + "px";

        center_mulch_img.style.height = h / d + "px";
        get_quote_img.style.height = h / d + "px";

        download_img.style.height = h / d + "px";
        upload_img.style.height = h / d + "px";

        //instructions_body . style . height          = y - 20 + "px"

        //t += Math . floor ( h * .1 )

        instructions_dialog.style.height = t + "px";
      };
      const Resize_info_dialog = (args) => {
        let t = 0;
        let y;
        let h = Math.floor(innerHeight * 0.8);

        y = Math.floor(h * 0.04);
        info_dialog.style.padding = y + "px";
        t += y * 1;

        y = Math.floor(h * 0.1);
        info_dialog_title.style.height = y + "px";
        t += y;

        y = Math.floor(h * 0.6);
        info_content.style.height = y + "px";
        t += y;

        info_body.style.height = y - 20 + "px";

        //t += Math . floor ( h * .1 )

        info_dialog.style.height = t + "px";
      };
      const Resize_email_dialog = (args) => {
        let t = 0;
        let y;
        let h = Math.floor(innerHeight * 0.8);

        y = Math.floor(h * 0.04);
        email_dialog.style.padding = y + "px";
        t += y * 1;

        y = Math.floor(h * 0.1);
        email_dialog_title.style.height = y + "px";
        t += y;

        y = Math.floor(h * 0.2);
        playground_snapshot.style.height = y + "px";
        t += y;

        y = Math.floor(h * 0.05);
        tab_bar.style.height = y + "px";
        t += y;

        y = Math.floor(h * 0.5);
        tab_content.style.height = y + "px";
        t += y;

        email_body.style.height = y - 20 + "px";

        y = Math.floor(h * 0.01);
        button_bar.style.height = y + "px";
        t += y;

        t += Math.floor(h * 0.1);

        email_dialog.style.height = t + "px";
      };
      const Hide_info = (args) => {
        $("#info_dialog").hide();
      };
      const Update_measurements = (args) => {
        let box = new THREE.Box3();
        for (let mesh of picked_meshes) box.expandByObject(mesh);

        let size = new THREE.Vector3();
        box.getSize(size);
        measurements =
          (size.x * Meters2Feet).toFixed(2) +
          "' x " +
          (size.y * Meters2Feet).toFixed(2) +
          "' x " +
          (size.z * Meters2Feet).toFixed(2) +
          "'";
      };
      const View_all = (args) => {
        let box = new THREE.Box3();
        for (let mesh of picked_meshes) box.expandByObject(mesh);

        let sphere = new THREE.Sphere();
        box.getBoundingSphere(sphere);
        let d = 5 * sphere.radius;
        if (d == 0) d = Math.sqrt(200);

        camera.position.normalize();
        camera.position.multiplyScalar(d);
        orbitControls.update();
        if (window.syncWorldRotationWithCamera) syncWorldRotationWithCamera();
      };
      const Show_contact_tab = (args) => {
        contact_tab_button.className = "foreground_tab_button";
        product_tab_button.className = "background_tab_button";
        contact_tab.style.display = "block";
        product_tab.style.display = "none";
      };
      const Show_product_tab = (args) => {
        product_tab_button.className = "foreground_tab_button";
        contact_tab_button.className = "background_tab_button";
        product_tab.style.display = "block";
        contact_tab.style.display = "none";
      };
      const Enable_disable_send_email_button = (args) => {
        const isValidEmail = (email) => {
          const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          return re.test(email);
        };
        
        const isValidPhone = (phone) => {
          const re = /^[\+]?[1-9][\d]{0,15}$/;
          return phone.length >= 10;
        };
        
        const isValidZip = (zip) => {
          const re = /^\d{5}(-\d{4})?$/;
          return re.test(zip) || zip.length >= 3;
        };
        
        // Clear previous error styles
        document.querySelectorAll('#email_dialog input').forEach(input => {
          input.style.borderColor = '#e0e0e0';
        });
        
        // Validate and highlight errors
        let isValid = true;
        
        if (first_name.value.trim().length == 0) {
          first_name.style.borderColor = '#ff4444';
          isValid = false;
        }
        
        if (last_name.value.trim().length == 0) {
          last_name.style.borderColor = '#ff4444';
          isValid = false;
        }
        
        if (!isValidEmail(email.value.trim())) {
          email.style.borderColor = '#ff4444';
          isValid = false;
        }
        
        if (!isValidPhone(phone_number.value.trim())) {
          phone_number.style.borderColor = '#ff4444';
          isValid = false;
        }
        
        if (!isValidZip(zip_code.value.trim())) {
          zip_code.style.borderColor = '#ff4444';
          isValid = false;
        }
        
        if (picked_meshes.length == 0) {
          isValid = false;
        }
        
        send_email_button.disabled = !isValid;
        
        // Update button text based on validation
        if (picked_meshes.length == 0) {
          send_email_button.textContent = 'Add items to your design first';
        } else if (!isValid) {
          send_email_button.textContent = 'Complete required fields';
        } else {
          send_email_button.textContent = 'Send Quote Request';
        }
      };
      const Open_file = (args) => {
        let fileReader = new FileReader();
        fileReader.onload = function (event) {
          blueprint.restore({ state: event.target.result });
        };
        fileReader.readAsText(args.files[0]);
      };
      const Save = (args) => {
        Upload({ text: blueprint.get_snapshot(), filename: "blueprint.json" });
      };
      const Open_file_button_change_listener = (args) => {
        file_button.removeEventListener(
          "change",
          Open_file_button_change_listener,
          false
        );
        Open_file({ files: file_button.files });
      };
      const Open = (args) => {
        file_button.addEventListener(
          "change",
          Open_file_button_change_listener,
          false
        );
        file_button.click();
      };
      const Upload = (args) => {
        let blob = new Blob([args.text], { type: "text/plain" });
        link.href = URL.createObjectURL(blob);
        link.download = args.filename || "data.json";
        link.dispatchEvent(new MouseEvent("click"));
      };
      const Lookup_yaw = (args) => {
        return Yaws[
          (args.host_model_yaw / 45) * 8 +
            args.host_joint_direction * 4 +
            args.plug_joint_direction
        ];
      };
      const Ddd2dd = (args) => {
        const vector = new THREE.Vector3();
        const widthHalf = 0.5 * renderer.getContext().canvas.width;
        const heightHalf = 0.5 * renderer.getContext().canvas.height;

        args.object3D.updateMatrixWorld();
        vector.setFromMatrixPosition(args.object3D.matrixWorld);
        vector.project(camera);

        vector.x = vector.x * widthHalf + widthHalf;
        vector.y = -(vector.y * heightHalf) + heightHalf;

        return new THREE.Vector2(vector.x, vector.y);
      };
      const Find_closest_available_joint = (args) => {
        let result = null;
        if (!plug_joint) return result;

        let min_joint_distance_squared = Infinity;
        for (let model of models_with_available_joints) {
          for (let joint of model.joints) {
            let position = Ddd2dd({ object3D: joint });
            let distance_squared = args.position.distanceToSquared(position);
            if (
              distance_squared < min_joint_distance_squared &&
              (plug_joint.layer == "*" ||
                joint.layer == "*" ||
                joint.layer == plug_joint.layer)
            ) {
              min_joint_distance_squared = distance_squared;
              result = joint;
            }
          }
        }
        return result;
      };
      const Load_image_base_64 = (args) => {
        return new Promise((resolve, reject) => {
          let img = document.createElement("img");
          img.addEventListener("load", function (event) {
            resolve({ resolution: img });
          });
          img.src = args.base_64;
        });
      };
      const Load_base_64 = (args) => {
        return new Promise((resolve, reject) => {
          let loader = new THREE.GLTFLoader();
          loader.load(args.base_64, (glb) => {
            resolve({ resolution: glb.scene });
          });
        });
      };
      const Load_file = (args) => {
        let filename = args.file.name;
        let splits = filename.split(".");
        let extension = splits.pop().toLowerCase();
        let name = splits.pop().split("/").pop();

        let fileReader = new FileReader();
        fileReader.filename_name = name;
        fileReader.onload = function (event) {
          new Model()
            .promise({ base_64: event.target.result })
            .then((resolution) => {
              let model = resolution.resolution;
              Categories[category_index].children.push({
                name: fileReader.filename_name,
                thumbnail: thumbnailer.nail_it({ model: model }),
                model: model,
                glb:
                  "data:application/octet-stream;base64," + event.target.result,
              });
              Show_items();

              if (!display_items) {
                // open
                $(".right-bar").css("right", "10px");
                $("#show-right-btn").css("right", `calc(26vh + 40px)`);
                $(".bottom-controls-right").css("right", `calc(26vh + 40px)`);
                display_items = true;
              }
            });
        };
        fileReader.readAsDataURL(args.file);
      };
      const Load_files = (args) => {
        for (let i = 0; i < args.files.length; i++) {
          Load_file({ file: args.files[i] }).then((args) => {});
        }
      };
      const Allow_drop = (event) => {
        event.preventDefault();
      };
      const Drop = (event) => {
        event.preventDefault();

        if (event.dataTransfer.items)
          for (let i = 0; i < event.dataTransfer.items.length; i++) {
            if (event.dataTransfer.items[i].kind === "file") {
              Load_file({ file: event.dataTransfer.items[i].getAsFile() });
            }
          }
        else Load_files({ files: event.dataTransfer.files });
      };
      const Render = (args) => {
        if (picked_mesh) {
          picked_mesh.model.mesh.traverse(function (mesh) {
            mesh.ov = mesh.visible;
            mesh.visible = false;
          });

          if (
            picked_mesh.name.indexOf("roof") == -1 &&
            picked_mesh.name.indexOf("flag") == -1
          ) {
            let colorized = 0;
            picked_mesh.model.mesh.traverse(function (mesh) {
              if (mesh.name.indexOf("_colorize_") != -1) {
                mesh.visible = true;
                while (mesh != null) {
                  mesh.visible = true;
                  mesh = mesh.parent;
                }
                colorized++;
              }
            });
            if (colorized == 0) {
              picked_mesh.model.mesh.traverse(function (mesh) {
                mesh.visible = true;
              });
            }
          } else {
            let mesh = picked_mesh;
            while (mesh != null) {
              mesh.visible = true;
              mesh = mesh.parent;
            }
          }
        } else {
          for (let model of Model.instances)
            if (model.mesh) model.mesh.visible = model.selected;
        }
        if (plug_model) plug_model.mesh.visible = true;
        scene.background = null;
        renderer.setRenderTarget(scene_render_target);
        renderer.clear();
        renderer.render(scene, camera);
        if (plug_model) plug_model.mesh.visible = false;
        if (picked_mesh) {
          picked_mesh.model.mesh.traverse(function (mesh) {
            mesh.visible = mesh.ov;
          });
          picked_mesh.model.mesh.visible = false;
        } else {
          for (let model of Model.instances)
            if (model.mesh) model.mesh.visible = false;
        }

        renderer.setRenderTarget(null);
        renderer.clear();
        scene.background = white_color;

        if (skybox && skybox.visible) skybox.mesh.visible = true;
        renderer.render(scene, camera);
        if (skybox && skybox.visible) skybox.mesh.visible = false;
        scene.background = null;
        renderer.clearDepth();

        for (let mesh of picked_meshes) mesh.visible = true;
        if (plug_model) plug_model.mesh.visible = true;
        if (mulch_enabled && mulch)
          for (let mesh of mulch.meshes) mesh.visible = true;
        renderer.render(scene, camera);
        if (mulch_enabled && mulch)
          for (let mesh of mulch.meshes) mesh.visible = false;
        if (plug_model) plug_model.mesh.visible = false;
        for (let mesh of picked_meshes) mesh.visible = false;

        outliner.outline({ render_target: scene_render_target });

        if (show_mesurements) {
          context.font = measurements_font_height + "px Impact";
          context.fillStyle = "black";
          let w = context.measureText(measurements).width;
          let x = (canvas.width - w) / 2;
          let y = canvas.height - measurements_font_height - 10;
          context.fillText(measurements, x - 0, y - 2);
          context.fillStyle = "black";
          context.fillText(measurements, x - 0, y - 1);
          context.fillStyle = "black";
          context.fillText(measurements, x + 1, y - 0);
          context.fillStyle = "black";
          context.fillText(measurements, x + 2, y - 0);
          context.fillStyle = "black";
          context.fillText(measurements, x - 0, y + 1);
          context.fillStyle = "black";
          context.fillText(measurements, x - 0, y + 2);
          context.fillStyle = "black";
          context.fillText(measurements, x - 1, y - 0);
          context.fillStyle = "black";
          context.fillText(measurements, x - 2, y - 0);
          context.fillStyle = "white";
          context.fillText(measurements, x, y);
        }
      };
      const Resize = (args) => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        scene_render_target.setSize(window.innerWidth, window.innerHeight);
        email_render_target.setSize(window.innerWidth, window.innerHeight);
        outliner.set_size({
          width: window.innerWidth,
          height: window.innerHeight,
        });

        Resize_email_dialog();
        Resize_instructions_dialog();

        Render();
      };
      const Change_flag_color = (color) => {
        picked_mesh.material.color = new THREE.Color(color);
        Hide_options();
      };
      const Change_roof_canopy_color = (color) => {
        let model = picked_mesh.model;
        if (model.roof_poly_mesh) model.roof_poly_mesh.visible = false;
        model.roof_canopy_mesh.visible = true;
        if (color == "tricolors") {
          model.roof_canopy_mesh.traverse((mesh) => {
            if ("material" in mesh)
              mesh.material = model.roof_canopy_material.clone();
          });
        } else {
          model.roof_canopy_mesh.traverse((mesh) => {
            if ("material" in mesh)
              mesh.material = new THREE.MeshStandardMaterial({
                color: color,
                side: THREE.DoubleSide,
              });
          });
        }

        model.ruf = "canopy";
        model.ruf_color = color;

        Hide_options();
      };
      const Change_roof_poly_color = (color) => {
        let model = picked_mesh.model;
        model.roof_canopy_mesh.visible = false;
        model.roof_poly_mesh.visible = true;
        model.roof_poly_mesh.traverse((mesh) => {
          if ("material" in mesh)
            mesh.material.color = new THREE.Color(color);
        });

        model.ruf = "poly";
        model.ruf_color = color;

        Hide_options();
      };
      const Colorize = (color) => {
        picked_mesh.model.colorized = color;

        let s = color.toString(16);
        if (s.length < 6) s = "0" + s;
        if (s.length < 6) s = "0" + s;
        let c = new THREE.Color("#" + s);

        picked_mesh.model.mesh.traverse((mesh) => {
          if (mesh.name.indexOf("_colorize_") != -1) mesh.material.color = c;
        });
        Hide_options();
      };
      const Key_up = (args) => {
        switch (Keys.code) {
          case Keys.esc:
            {
              for (let model of Model.instances) model.selected = false;

              picked_mesh = null;
              host_joint = null;
              plug_joint = null;
              plug_joint_index = -1;
              plug_model = null;

              Mode.mode = Mode.normal;

              Hide_options();
            }
            break;
          case Keys.space:
            {
              if (!plug_model) return;

              if (plug_model.joints.length == 1) {
                switch (plug_model.mirrorx) {
                  case 0:
                    {
                      plug_model.mesh.scale.z = -1;
                      plug_model.mirrorx = 1;
                    }
                    break;
                  case 1:
                    {
                      plug_model.mesh.scale.z = 1;
                      plug_model.mirrorx = 0;
                    }
                    break;
                }
              } else {
                if (++plug_joint_index >= plug_model.joints.length)
                  plug_joint_index = 0;

                plug_joint = plug_model.joints[plug_joint_index];

                plug_model.yaw = plug_joint_index * 90;
              }
            }
            break;
        }
      };
      const Item_clicked = (args) => {
        picked_mesh = null;
        host_joint = null;
        plug_joint = null;
        plug_joint_index = -1;
        plug_model = null;

        plug_model =
          Categories[category_index].children[item_index].model.clone();

        // Check tower type and apply correct rotation for front-facing direction
        if(plug_model.mesh.children[0].name.includes("King") || plug_model.mesh.children[0].name.includes("summitglb")){
          // King's Tower and Watchtower need 90-degree rotation due to different front direction
          plug_model.mesh.rotation.y = Math.PI / 2; // 90 degrees in radians
          plug_model.yaw = 90; // Set yaw for consistency with attachment system
        } else {
          // Other towers use standard orientation
          plug_model.mesh.rotation.y = 0; // 0 degrees
          plug_model.yaw = 0; // Set yaw for consistency with attachment system
        }
        
        // Apply default gray color to trim/accessories when cloned
        if (category_index === 1 || category_index === 3 || category_index === 4 || category_index === 5) {
          if (plug_model.colorized) {
            let color_string = plug_model.colorized.toString(16);
            if (color_string.length < 5) color_string = "0" + color_string;
            if (color_string.length < 6) color_string = "0" + color_string;
            let gray_color = new THREE.Color("#" + color_string);
            
            plug_model.mesh.traverse((mesh) => {
              if (mesh.name.indexOf("_colorize_") != -1) {
                mesh.material.color = gray_color;
              }
            });
          }
        }
        
        scene.add(plug_model.mesh);

        for (let model of Model.instances) model.selected = false;
        //plug_model . selected = true

        if (picked_meshes.length > 0) {
          plug_joint = null;
          if (plug_model.joints.length > 0) {
            plug_joint_index = 0;
            plug_joint = plug_model.joints[plug_joint_index];
          }
          Mode.mode = Mode.plugging;
        } else {
          models_with_available_joints.push(plug_model);
          picked_meshes.push(plug_model.mesh);
          plug_model = null;
          Mode.mode = Mode.normal;

          Show_items();
          Update_measurements();
        }
      };
      const Refresh = (args) => {
        blueprint.refresh(args);
      };

      const Send_mail = async (e) => {
        try {
          throbber.style.display = "block";

          // Generate PDF with parts list
          const pdf = await generatePartsPDF();
          const pdfBase64 = pdf.output('datauristring').split(',')[1]; // Remove data:application/pdf;base64,

          // Prepare data for PHP backend
          const emailData = {
            first_name: first_name.value,
            last_name: last_name.value,
            email: email.value,
            phone_number: phone_number.value,
            zip_code: zip_code.value,
            notes: notes.value,
            design_image: email_scene_snapshot,
            parts_pdf: pdfBase64,
            part_list: part_list,
            blueprint_json: blueprint.get_snapshot()
          };

          // Use the send_email.php endpoint (works for both Node.js and Apache)
          const endpoint = './send_email.php';
          
          // Send email via PHP backend
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(emailData)
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
            throw new Error(`Email Error: ${errorData.error || response.statusText}`);
          }

          const result = await response.json();
          console.log('Email sent successfully:', result);

          email_dialog.style.display = "none";
          throbber.style.display = "none";
          alert("Quote request sent successfully! Our sales team will contact you soon.");
          
          // Clear form
          first_name.value = '';
          last_name.value = '';
          email.value = '';
          phone_number.value = '';
          zip_code.value = '';
          notes.value = '';
          
        } catch (error) {
          console.error('Error sending email:', error);
          throbber.style.display = "none";
          alert("Error sending quote request. Please try again or contact us directly at sales@playmorswingsets.com");
        }
      };
      
      const generatePartsPDF = async () => {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        
        // Header
        doc.setFontSize(20);
        doc.text('Yard Designer - Quote Request', 20, 30);
        
        // Customer info
        doc.setFontSize(12);
        let yPos = 50;
        doc.text(`Customer: ${first_name.value} ${last_name.value}`, 20, yPos);
        yPos += 10;
        doc.text(`Email: ${email.value}`, 20, yPos);
        yPos += 10;
        doc.text(`Phone: ${phone_number.value}`, 20, yPos);
        yPos += 10;
        doc.text(`Zip Code: ${zip_code.value}`, 20, yPos);
        yPos += 20;
        
        if (notes.value) {
          doc.text(`Notes: ${notes.value}`, 20, yPos);
          yPos += 20;
        }
        
        // Design Preview Image
        doc.setFontSize(14);
        doc.text('Design Preview:', 20, yPos);
        yPos += 10;
        
        // Add the design image to PDF
        if (email_scene_snapshot) {
          try {
            // Calculate image dimensions to fit on page
            const maxWidth = 170;  // Max width in PDF units
            const maxHeight = 100; // Max height in PDF units
            
            doc.addImage(email_scene_snapshot, 'PNG', 20, yPos, maxWidth, maxHeight);
            yPos += maxHeight + 20; // Move position down after image
            
            // Start new page if needed
            if (yPos > 200) {
              doc.addPage();
              yPos = 20;
            }
          } catch (error) {
            console.log('Could not add image to PDF:', error);
            doc.text('Design image could not be added to PDF', 20, yPos);
            yPos += 20;
          }
        }
        
        // Parts list
        doc.setFontSize(14);
        doc.text('Parts List:', 20, yPos);
        yPos += 10;
        
        doc.setFontSize(10);
        for (let part of part_list) {
          doc.text(`• ${part.name}`, 25, yPos);
          yPos += 8;
          if (part.options && part.options.length > 0) {
            for (let option of part.options) {
              doc.text(`  - ${option}`, 30, yPos);
              yPos += 6;
            }
          }
          yPos += 5;
          
          // Start new page if needed
          if (yPos > 280) {
            doc.addPage();
            yPos = 20;
          }
        }
        
        return doc;
      };
      
      const generatePartsListText = () => {
        let text = `Quote Request from ${first_name.value} ${last_name.value}\n\n`;
        text += `Contact Info:\n`;
        text += `Email: ${email.value}\n`;
        text += `Phone: ${phone_number.value}\n`;
        text += `Zip Code: ${zip_code.value}\n\n`;
        
        if (notes.value) {
          text += `Notes: ${notes.value}\n\n`;
        }
        
        text += `Parts List:\n`;
        for (let part of part_list) {
          text += `• ${part.name}\n`;
          if (part.options && part.options.length > 0) {
            for (let option of part.options) {
              text += `  - ${option}\n`;
            }
          }
          text += `\n`;
        }
        
        return text;
      };
      
      const generatePartsListHTML = () => {
        let html = '<ul style="margin: 10px 0; padding-left: 20px;">';
        for (let part of part_list) {
          html += `<li style="margin: 8px 0; font-weight: bold;">${part.name}`;
          if (part.options && part.options.length > 0) {
            html += '<ul style="margin: 5px 0; padding-left: 20px; font-weight: normal;">';
            for (let option of part.options) {
              html += `<li style="margin: 3px 0; color: #666;">${option}</li>`;
            }
            html += '</ul>';
          }
          html += '</li>';
        }
        html += '</ul>';
        return html;
      };
      const Color2Name = (color) => {
        let result = "Tri colored";

        let hex_color = color.getHexString();
        if (hex_color == "01664b") result = "Green";
        if (hex_color == "00664b") result = "Green";
        if (hex_color == "004983") result = "Blue";
        if (hex_color == "ffcb05") result = "Yellow";
        if (hex_color == "93293b") result = "Red";
        if (hex_color == "5b5e67") result = "Gray";

        return result;
      };
      const Setup_email_snapshot = (args) => {
        renderer.setRenderTarget(email_render_target);
        renderer.clear();
        scene.background = white_color;

        if (skybox && skybox.visible) skybox.mesh.visible = true;
        renderer.render(scene, camera);
        if (skybox && skybox.visible) skybox.mesh.visible = false;
        scene.background = null;
        renderer.clearDepth();

        for (let mesh of picked_meshes) mesh.visible = true;
        if (plug_model) plug_model.mesh.visible = true;
        if (mulch_enabled && mulch)
          for (let mesh of mulch.meshes) mesh.visible = true;
        renderer.render(scene, camera);
        if (mulch_enabled && mulch)
          for (let mesh of mulch.meshes) mesh.visible = false;
        if (plug_model) plug_model.mesh.visible = false;
        for (let mesh of picked_meshes) mesh.visible = false;

        let render_target_pixels = new Uint8ClampedArray(
          4 * email_render_target.width * email_render_target.height
        );
        renderer.readRenderTargetPixels(
          email_render_target,
          0,
          0,
          email_render_target.width,
          email_render_target.height,
          render_target_pixels
        );
        let flipped_render_target_pixels = new Uint8ClampedArray(
          4 * email_render_target.width * email_render_target.height
        );
        for (let y = 0; y < email_render_target.height; y++) {
          for (let x = 0; x < email_render_target.width; x++) {
            let si = y * email_render_target.width * 4 + x * 4;
            let di =
              (email_render_target.height - y) * email_render_target.width * 4 +
              x * 4;
            flipped_render_target_pixels[di + 0] = render_target_pixels[si + 0];
            flipped_render_target_pixels[di + 1] = render_target_pixels[si + 1];
            flipped_render_target_pixels[di + 2] = render_target_pixels[si + 2];
            flipped_render_target_pixels[di + 3] = render_target_pixels[si + 3];
          }
        }
        let imageData = new ImageData(
          flipped_render_target_pixels,
          email_render_target.width,
          email_render_target.height
        );
        let canvas = document.createElement("canvas");
        canvas.width = email_render_target.width;
        canvas.height = email_render_target.height;
        let context = canvas.getContext("2d");
        context.putImageData(imageData, 0, 0);

        renderer.setRenderTarget(null);

        email_scene_snapshot = canvas.toDataURL("image/png");
      };
      const Set_up_email = (args) => {
        // Add small delay to ensure scene is fully updated after rotate/move
        setTimeout(() => {
          Setup_email_snapshot();
        playground_snapshot.innerHTML =
          '<img style = "height : 100% ;"src = "' +
          email_scene_snapshot +
          '"/>';
        let html = '<table id = "product_table"><tbody id = "email_body">';
        part_list = [];
        for (let picked_mesh of picked_meshes) {
          let model = picked_mesh.model;

          html += "<tr>";

          let thumbnail = thumbnailer.nail_it({ model: model });
          let name =
            Categories[model.category].children[model.children_index].name;
          let ruf = "";
          if (model.roof_canopy_mesh)
            if (model.roof_canopy_mesh.visible)
              ruf =
                Color2Name(model.roof_canopy_mesh.material.color) + " canopy";
          if (ruf == "" && model.roof_poly_mesh) ruf = "Green poly";
          let colorized_color_name = "";

          model.mesh.traverse((mesh) => {
            if (mesh.name.indexOf("_colorize_") != -1)
              colorized_color_name =
                Color2Name(new THREE.Color(mesh.material.color)) +
                " base color";
          });

          if (model.colorized) {
            colorized_color_name = Color2Name(new THREE.Color(model.colorized));
            colorized_color_name += " base color";
          }

          let options = [];
          if (ruf) options.push(ruf);
          if (colorized_color_name.length > 0 && name.indexOf("floor") < 0)
            options.push(colorized_color_name);

          // look for flags
          let flag_list = [];
          model.mesh.traverse((mesh) => {
            let splits = mesh.name.toLowerCase().split(",");
            if (splits[0].toLowerCase().startsWith("flag")) {
              let found = false;
              let i = 0;
              let color_name = Color2Name(mesh.material.color);
              while (!found && i < flag_list.length) {
                found = color_name == flag_list[i++].color_name;
              }
              if (found) {
                flag_list[--i].count++;
              } else
                flag_list.push({
                  count: 1,
                  color_name: color_name,
                });
            }
          });
          for (let flag of flag_list)
            if (flag.count > 0) {
              let s = flag.count + " " + flag.color_name;
              if (flag.count == 1) s += " flag";
              else s += " flags";
              options.push(s);
            }

          part_list.push({
            thumbnail: thumbnail,
            thumbnail_size: Thumbnailer.thumbnail_size,
            name: name,
            options: options,
          });

          html +=
            '<td style = "width : 33%;"><img style = "width : 128px ; height : 128px ;" src = "' +
            thumbnail +
            '"/></td>';
          html += "<td>" + name + "</td>";
          html += "<td>";
          for (let option of options) html += option + "<br>";
          html += "</td>";
          html += "</tr>";
        }
        html += "</table>";

        product_tab.innerHTML = html;

        Resize_email_dialog();

        $("#email_dialog").show();
        }, 100); // 100ms delay to ensure scene is updated
      };
      const Toggle_measurements = (args) => {
        show_mesurements = !show_mesurements;
      };
      const Main = (args) => {
        // Email system ready (using Zeptomail API)
        
        file_button = document.createElement("input");
        file_button.multiple = false;
        file_button.type = "file";

        document.ondrop = Drop;
        document.ondragover = Allow_drop;

        canvas = document.createElement("canvas");
        context = canvas.getContext("2d");
        canvas.style.position = "absolute";
        canvas.style.left = "0";
        canvas.style.top = "0";
        document.body.appendChild(canvas);

        scene = new THREE.Scene();
        white_color = new THREE.Color("white");

        // Create world group to rotate all 3D objects to match camera rotation
        window.worldGroup = new THREE.Group();
        scene.add(worldGroup);

        camera = new THREE.PerspectiveCamera(50, 1, 0.1, 20000);

        let ambientLight = new THREE.AmbientLight(0x808080);
        scene.add(ambientLight);

        let dirLightGroup = new THREE.Group();
        scene.add(dirLightGroup);

        let rightDirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        rightDirLight.position.set(3, 12, 17);
        rightDirLight.castShadow = true;
        rightDirLight.shadow.camera.near = 0.1;
        rightDirLight.shadow.camera.far = 500;
        rightDirLight.shadow.camera.right = 17;
        rightDirLight.shadow.camera.left = -17;
        rightDirLight.shadow.camera.top = 17;
        rightDirLight.shadow.camera.bottom = -17;
        rightDirLight.shadow.mapSize.width = 2048;
        rightDirLight.shadow.mapSize.height = 2048;
        rightDirLight.shadow.radius = 4;
        rightDirLight.shadow.bias = -0.0005;
        dirLightGroup.add(rightDirLight);

        let leftDirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        leftDirLight.position.set(-3, 12, -17);
        leftDirLight.castShadow = true;
        leftDirLight.shadow.camera.near = 0.1;
        leftDirLight.shadow.camera.far = 500;
        leftDirLight.shadow.camera.right = 17;
        leftDirLight.shadow.camera.left = -17;
        leftDirLight.shadow.camera.top = 17;
        leftDirLight.shadow.camera.bottom = -17;
        leftDirLight.shadow.mapSize.width = 2048;
        leftDirLight.shadow.mapSize.height = 2048;
        leftDirLight.shadow.radius = 4;
        leftDirLight.shadow.bias = -0.0005;
        dirLightGroup.add(leftDirLight);

        scene_render_target = new THREE.WebGLRenderTarget(1, 1);
        email_render_target = new THREE.WebGLRenderTarget(
          canvas.width,
          canvas.height
        );

        renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.shadowMap.enabled = shadows;
        renderer.shadowMap.type = THREE.PCFShadowMap;
        renderer.autoClear = false;
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        orbitControls = new THREE.OrbitControls(camera, canvas);
        orbitControls.enableDamping = false;
        orbitControls.maxPolarAngle = Math.PI / 2 - 0.01;
        orbitControls.maxDistance = 49;

        mulch = new Mulch();
        skybox = new Skybox();
        blueprint = new Blueprint();
        outliner = new Outliner();
        thumbnailer = new Thumbnailer();

        Resize();
        //instructions_dialog . style . display = 'block'

        Load_image_base_64({ base_64: Assets[5] }).then((resolution) => {
          joint_image = resolution.resolution;
          joint_image_frame = 0;
          joint_image_frames = joint_image.width / joint_image.height;
        });

        intersection_point = new THREE.Vector3();

        // Set initial camera position with 90-degree rotations in X and Z axes (135 - 45)
        const distance = 14.14; // sqrt(10^2 + 10^2)
        const angleX = Math.PI / 3; // 45 degrees in radians
        const angleZ = Math.PI / 2; // 90 degrees in radians (135 - 45)
        
        // Apply rotations: rotate around X-axis first, then Z-axis with additional 90-degree Y rotation
        camera.position.set(
          distance * Math.sin(angleZ), // X component with Z rotation
          10 * Math.cos(angleX),       // Y component with X rotation  
          distance * Math.cos(angleZ)  // Z component with Z rotation
        );
        camera.lookAt(intersection_point);
        
        // Function to synchronize world rotation with camera rotation
        window.syncWorldRotationWithCamera = function() {
          // Calculate camera's Y rotation based on its position relative to center
          const cameraVector = camera.position.clone().normalize();
          const cameraYRotation = Math.atan2(cameraVector.x, cameraVector.z);
          
          // Apply opposite rotation to world group to keep objects aligned
          worldGroup.rotation.y = -cameraYRotation;
          
          console.log('World rotation synced:', worldGroup.rotation.y * 180 / Math.PI, 'degrees');
        };
        
        // Apply initial world rotation based on initial camera position
        syncWorldRotationWithCamera();
        
        // Helper function to test different camera rotations
        window.setCameraRotation = function(degrees) {
          const radians = degrees * Math.PI / 180;
          const distance = camera.position.length();
          
          camera.position.set(
            distance * Math.sin(radians),
            camera.position.y,
            distance * Math.cos(radians)
          );
          
          camera.lookAt(intersection_point);
          orbitControls.update();
          syncWorldRotationWithCamera();
          
          console.log('Camera rotation set to:', degrees, 'degrees');
        };

        //document . oncontextmenu    = event => event . preventDefault ( )
        window.addEventListener("resize", Resize, false);
        canvas.addEventListener("pointerdown", function (event) {
          if (event.type === "touchstart")
            Pointers.position.set(
              event.touches[0].clientX,
              event.touches[0].clientY
            );
          else Pointers.position.set(event.x, event.y);

          Pointers.button = event.button;

          Pointers.target = event.target;

          Pointers.delta.set(0, 0);

          Pointer_down();
        });
        canvas.addEventListener("pointermove", function (event) {
          if (event.type === "touchstart")
            Pointers.position.set(
              event.touches[0].clientX,
              event.touches[0].clientY
            );
          else Pointers.position.set(event.x, event.y);

          Pointers.target = event.target;

          Pointers.delta.set(0, 0);
        });
        document.addEventListener("keyup", function (event) {
          Keys.code = event.keyCode;

          Keys.alt = event.altKey;
          Keys.control = event.ctrlKey;
          Keys.shift = event.shiftKey;

          Key_up();
        });

        interval_id = setInterval(Tik, 1000 / 33);
      };
    </script>

    <script src="./js/assets.js"></script>
    <script src="./js/categories.js"></script>
    <script src="./js/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="./js/three.min.js"></script>
    <script src="./js/GLTFLoader.js"></script>
    <script src="./js/OrbitControls.js"></script>

    <script>
      const Pointers = {
        position: new THREE.Vector2(),
        down_position: new THREE.Vector2(),
        old_position: new THREE.Vector2(),
        delta: new THREE.Vector2(),

        wil_delta: 0,

        button: -1,
        left_button: 0,
        middle_button: 1,
        right_button: 2,

        target: null,
      };
      const Keys = {
        code: 0,
        esc: 27,
        space: 32,
        f2: 113,
        i: 73,
        r: 85,
        alt: false,
        control: false,
        shift: false,
        left: 37,
        up: 38,
        right: 39,
        down: 40,
      };
      const poi = new THREE.Vector3();
      let display_items = false;
      let display_mulch = false;
      let display_email = false;
      let mulch_enabled = true;
      let category_index = 0;
      let item_index = 0;

      const Show_categories = function () {
        let index = 0;
        let html = "";
        switchboard = [];
        for (let category of Categories) {
          html +=
            '<h6 class="steps" id="steps-' +
            index +
            '">' +
            '<img class="step-image" src="' +
            category.thumbnail +
            '"/>' +
            '<div class="step-text">' +
            (index + 1) +
            "." +
            category.name +
            "</div>" +
            "</h6>";
          switchboard.push([]);
          index++;
        }
        sub_step_container.innerHTML = html;

        $(".steps").on("click", (event) => {
          if (event && event.currentTarget && event.currentTarget.id) {
            var index = event.currentTarget.id.replace(/^\D+/g, "");

            category_index = parseInt(index);
            Highlight_category();
            Show_items();
            Highlight_item();

            if (!display_items) {
              // open
              $(".right-bar").css("right", "10px");
              $("#show-right-btn").css("right", `calc(26vh + 40px)`);
              $(".bottom-controls-right").css("right", `calc(26vh + 40px)`);
              display_items = true;
            }
          }
        });
      };
      const Load_models = (args) => {
        let category_index = 0;
        for (let category of Categories) {
          let child_index = 0;
          for (let child of category.children) {
            child.model = new Model({
              category_child: child,
              category: category_index,
              children_index: child_index++,
            });
            
            // Set default gray color for categories
            // Categories 0, 1, 2 are Tower, Swing beam, Swings
            // Categories 3, 4, 5 typically contain trim/accessories in yard design software
            // Category 6 is Toys
            if (category_index === 0 || category_index === 1 || category_index === 2 || category_index === 3 || category_index === 4 || category_index === 5 || category_index === 6) {
              child.model.colorized = 0x5b5e67; // Default gray color
              
              // Apply gray color to mesh if it's already loaded
              if (child.model.mesh) {
                let color_string = child.model.colorized.toString(16);
                if (color_string.length < 5) color_string = "0" + color_string;
                if (color_string.length < 6) color_string = "0" + color_string;
                let gray_color = new THREE.Color("#" + color_string);
                
                child.model.mesh.traverse((mesh) => {
                  if (mesh.name.indexOf("_colorize_") != -1) {
                    mesh.material.color = gray_color;
                  }
                });
              }
            }
          }
          category_index++;
        }
      };
      const Show_items = function () {
        let index = 0;
        let html = "";
        let cabuse = [];
        switchboard[category_index] = [];
        for (let child of Categories[category_index].children) {
          child.index = index;
          if (child.model.capable()) {
            html +=
              '<h6 class="sub-items" id="sub-items-' +
              index +
              '">' +
              '<div class="sub-item-text">' +
              child.name +
              "</div>" +
              '<img class="sub-item-image" src="' +
              child.thumbnail +
              '"/>' +
              "</h6>";
            switchboard[category_index].push(child.index);
          } else cabuse.push(child);

          index++;
        }
        for (let child of cabuse) {
          html +=
            '<h6 class="sub-items" id="sub-items-' +
            index +
            '">' +
            '<div class="sub-item-text">' +
            child.name +
            "</div>" +
            //'<img class="sub-item-image" src="' + child . thumbnail + '"/>'    +
            //'<img class="sub-item-image" style = "filter : blur(5px);" src="' + child . thumbnail + '"/>'    +
            //'<img class="sub-item-image" style = "filter : grayscale(100%);" src="' + child . thumbnail + '"/>'    +
            //'<img class="sub-item-image" src="' + child . thumbnail + '"/>'    +
            '<img class="sub-item-image" style = "filter : grayscale(100%);" src="' +
            child.thumbnail +
            '"/>' +
            "</h6>";
          switchboard[category_index].push(child.index);
        }

        sub_item_container.innerHTML = html;

        $(".sub-items").on("click", (event) => {
          if (event && event.currentTarget && event.currentTarget.id) {
            var index = event.currentTarget.id.replace(/^\D+/g, "");

            item_index = parseInt(index);
            Highlight_item(switchboard[category_index].indexOf(item_index));

            Item_clicked();
          }
        });
      };
      const Highlight_category = function () {
        $(".steps img").css("opacity", 1);
        $(".steps img").css("background", "transparent");
        $(`#steps-${category_index} img`).css("opacity", 1);
        $(`#steps-${category_index} img`).css("background", "#c0c0c0");
      };
      const Highlight_item = function () {
        $(".sub-item-image").css("opacity", 1);
        $(".sub-item-image").css("background", "transparent");
        $(`#sub-items-${item_index} img`).css("opacity", 1);
        $(`#sub-items-${item_index} img`).css("background", "#c0c0c0");
      };

      $("#controls-buttons-info").on("click", (event) => {
        show_info = !show_info;
        if (show_info) Show_info();
        else Hide_info();
      });
      $("#controls-buttons-recenter").on("click", (event) => {
        View_all();
      });
      $("#controls-buttons-refresh").on("click", (event) => {
        Refresh();
      });
      $("#controls-buttons-undo").on("click", (event) => {
        blueprint.undo();
      });
      $("#controls-buttons-center-mulch").on("click", (event) => {
        Center();
      });
      $("#zum_in_button").on("click", (event) => {
        Zumin();
      });
      $("#zum_out_button").on("click", (event) => {
        Zumout();
      });

      $("#controls-buttons-mulch").on("click", (event) => {
        display_mulch = !display_mulch;
        if (display_mulch) {
          $(".mulch").show();
        } else {
          $(".mulch").hide();
        }
      });
      $("#controls-buttons-switch").on("click", (event) => {
        skybox.toggle();
      });
      $(".mulch-options-item-checkbox").on("click", (event) => {
        mulch_enabled = !mulch_enabled;
        if (mulch_enabled) {
          $(".mulch-options-item-checkbox img").show();
        } else {
          $(".mulch-options-item-checkbox img").hide();
        }
      });
      $("#mulch-options-material-left").on("click", (event) => {
        if (mulch) mulch.build({ plane_texture_index: 0 });
      });
      $("#mulch-options-material-right").on("click", (event) => {
        if (mulch) mulch.build({ plane_texture_index: 1 });
      });
      $("#mulch-options-crub-left").on("click", (event) => {
        if (mulch) mulch.build({ bounds_texture_index: 0 });
      });
      $("#mulch-options-crub-right").on("click", (event) => {
        if (mulch) mulch.build({ bounds_texture_index: 1 });
      });
      $("#controls-buttons-measurement").on("click", (event) => {
        Toggle_measurements();
      });
      $("#controls-buttons-help").on("click", (event) => {
        Help();
      });

      $("#controls-buttons-upload").on("click", (event) => {
        Open();
      });
      $("#controls-buttons-download").on("click", (event) => {
        Save();
      });
      $("#show-right-btn").on("click", (event) => {
        if (display_items) {
          $(".right-bar").css("right", "-35vh");
          $("#show-right-btn").css("right", "3vh");
          $(".bottom-controls-right").css("right", "15px");
        } else {
          $(".right-bar").css("right", "10px");
          $("#show-right-btn").css("right", `calc(26vh + 40px)`);
          $(".bottom-controls-right").css("right", `calc(26vh + 40px)`);
        }
        display_items = !display_items;
      });
      $("#custom-controls-delete").on("click", (event) => {
        Trash_picked_mesh();
      });
      $("#controls-buttons-mail").on("click", (event) => {
        // Check actual dialog visibility instead of relying on display_email variable
        if ($("#email_dialog").is(":visible")) {
          $("#email_dialog").hide();
          display_email = false;
        } else {
          Set_up_email();
          display_email = true;
        }
      });

      const Hide_options = (args) => {
        $("#measurement-display").css("display", "none");
        $(".custom-controls").css("display", "none");
        $(".custom-controls-roof").css("display", "none");

        for (let model of Model.instances) model.selected = false;
      };

      Load_models();
      Show_categories();
      Show_items();
      Highlight_category();
      Highlight_item();

      $(".right-bar").css("right", "10px");
      $("#show-right-btn").css("right", `calc(26vh + 40px)`);
      $(".bottom-controls-right").css("right", `calc(26vh + 40px)`);

      Main();
    </script>
  </body>
</html>